World Name,Theorem Name,Natural Language,Predicted Formalization,True Tactic,True Goal State,Predicted Goal State,Tactics Match,Is Incorrect Tactic,Correctly Identified As Wrong
exact_2,exact_2_dev_1,-- We simplify the hypothesis of 0 + x = 0 + y + 2 to x = 0 + x + 2.,rw [zero_add] at h,rw [zero_add] at h,"y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
","y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
",Yes,No,Yes
exact_2,exact_2_dev_2,-- 0 + x = 0 + y + 2 -> x = 0 + y + 2,rw [zero_add] at h,rw [zero_add] at h,"y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
","y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
",Yes,No,Yes
exact_2,exact_2_dev_1,-- We simplify the hypothesis of 0 + x = 0 + y + 2 to x = 0 + x + 2.,rw [zero_add] at h,rw [zero_add] at h,"y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
","y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
",Yes,No,Yes
exact_2,exact_2_dev_2,-- 0 + x = 0 + y + 2 -> x = 0 + y + 2,"rw [zero_add] at h, rw [zero_add] at h, exact h",rw [zero_add] at h,"y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
","y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
",No,No,Yes
World Name,Theorem Name,Natural Language,Predicted Formalization,True Tactic,True Goal State,Predicted Goal State,Tactics Match,Is Incorrect Tactic,Correctly Identified As Wrong
zero_mul,zero_mul_dev_1,-- Proof by induction on m with base case 0 * 0 = 0 and inductive step 0 * d + 1 = 0,induction m with d hd,induction m with d hd,"case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
","case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",Yes,No,Yes
zero_mul,zero_mul_dev_1,-- First prove base case. Simplify LHS 0 * 0 to 0,rw [mul_zero],rw [mul_zero],"case zero
⊢ 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
","case zero
⊢ 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",Yes,No,Yes
zero_mul,zero_mul_dev_1,-- Simplify the LHS 0 * d + 0 to 0 + 0 using the definition of addition,rw [add_zero],rw [add_zero],"case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * d = 0
",error,Yes,Yes,Yes
zero_mul,zero_mul_dev_1,-- This is exactly the inductive hypothesis so we can complete the proof.,rfl,exact hd,,error,No,Yes,Yes
zero_mul,zero_mul_dev_2,-- Proof by induction on m with base case 0 * 0 = 0 and inductive step 0 * d + 1 = 0,induction m with d hd,induction m with d hd,"case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
","case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",Yes,No,Yes
zero_mul,zero_mul_dev_2,-- That proves the base case.,rfl,rfl,"case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",error,Yes,Yes,Yes
zero_mul,zero_mul_dev_2,-- This is exactly the inductive hypothesis so we can complete the proof.,rfl,exact hd,,error,No,Yes,Yes
World Name,Theorem Name,Natural Language,Predicted Formalization,True Tactic,True Goal State,Predicted Goal State,Tactics Match,Is Incorrect Tactic,Correctly Identified As Wrong
mul_left_ne_zero,mul_left_ne_zero__dev_1,-- Assume that b equals 0.,intro hd,intro hb,"a b : ℕ
h : a * b ≠ 0
hb : b = 0
⊢ False
","a b : ℕ
h : a * b ≠ 0
hd : b = 0
⊢ False
",No,No,Yes
mul_left_ne_zero,mul_left_ne_zero__dev_1,-- We use reflexivity to prove the goal of 0 = 0.,rfl,rfl,,error,Yes,Yes,Yes
mul_left_ne_zero,mul_left_ne_zero__dev_2,-- Assume that b equals 0.,intro hd,intro hd,"a b : ℕ
h : a * b ≠ 0
hd : b = 0
⊢ False
","a b : ℕ
h : a * b ≠ 0
hd : b = 0
⊢ False
",Yes,No,Yes
mul_left_ne_zero,mul_left_ne_zero__dev_2,-- We have 0 != 0 which is a contradiction.,exact zero_ne_zero.refl,tauto,,error,No,Yes,Yes
add_left_comm,add_left_comm_dev_1,"-- By associativity of addition, can change a + (b + c) into (a + b) + c",rw [add_assoc],rw [← add_assoc],"a b c : ℕ
⊢ a + b + c = b + (a + c)
",error,No,No,No
add_left_comm,add_left_comm_dev_1,"-- So we just need to show b + (a + c) = b + (a + c), which is true by reflexivity.",rfl,rfl,,error,Yes,Yes,Yes
add_left_comm,add_left_comm_dev_2,-- a + (b + c) = b + (a + c) -> (a + b) + c = b + (a + c),rw [add_assoc],rw [← add_assoc],"a b c : ℕ
⊢ a + b + c = b + (a + c)
",error,No,No,No
add_left_comm,add_left_comm_dev_2,-- lhs = rhs,"rw [← add_assoc, add_comm a b, add_assoc]",rfl,,error,No,Yes,Yes
World Name,Theorem Name,Natural Language,Predicted Formalization,True Tactic,True Goal State,Predicted Goal State,Tactics Match,Is Incorrect Tactic,Correctly Identified As Wrong
le_two,le_two_dev_1,-- Either x = 0 or x = succ y for some natural number y.,cases x with y,cases x with y,"case zero
hx : 0 ≤ 2
⊢ 0 = 0 ∨ 0 = 1 ∨ 0 = 2
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero
hx : 0 ≤ 2
⊢ 0 = 0 ∨ 0 = 1 ∨ 0 = 2
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- In the former case, we need to show 0 = 0 ∨ 0 = 1 ∨ 0 = 2, and we choose to show 0 = 0.","left, rfl",left,"case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,No,Yes
le_two,le_two_dev_1,-- This is clear by reflexivity.,rfl,rfl,"case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- In the latter case, either y = 0 or y = succ z for some natural number z.",cases y with z,cases y with z,"case succ.zero
hx : succ 0 ≤ 2
⊢ succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- In the former case, we must show succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2, and we choose to prove succ 0 = 1 ∨ succ 0 = _dev_2",right,right,"case succ.zero.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- To prove succ 0 = 1 ∨ succ 0 = 2, we choose to prove succ 0 = _dev_1",left,left,"case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- Rewriting using a theorem, need to show show succ 0 = succ 0.",rfl,rw [one_eq_succ_zero],"case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = succ 0
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,No,Yes
le_two,le_two_dev_1,-- This is clear by reflexivity.,rfl,rfl,"case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- In the latter case, we substitute 2 = succ 1 and 1 = succ 0 into what we know and what we have to show.","rw [two_eq_succ_one, one_eq_succ_zero] at hx ⊢","rw [two_eq_succ_one, one_eq_succ_zero] at hx ⊢","case succ.succ
z : ℕ
hx : succ (succ z) ≤ succ (succ 0)
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- We know that succ (succ z) ≤ succ (succ 0), so usinig a theorem we know succ z ≤ succ 0.",apply succ_le_succ at hx,apply succ_le_succ at hx,"case succ.succ
z : ℕ
hx : succ z ≤ succ 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- We know that succ z ≤ succ 0, so using a theorem we know that z ≤ 0.",apply succ_le_succ at hx,apply succ_le_succ at hx,"case succ.succ
z : ℕ
hx : z ≤ 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- Since z ≤ 0, using a theorem, z = 0.",apply le_zero at hx,apply le_zero at hx,"case succ.succ
z : ℕ
hx : z = 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- So, we need to show that succ (succ 0) = 0 ∨ succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0), so we choose to show that succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0)",right,right,"case succ.succ.h
z : ℕ
hx : z = 0
⊢ succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- But LHS = RHS, so this follows by reflexivity.",rfl,rfl,,"case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,Yes,No
le_two,le_two_dev_2,-- x = 0 (case 1) or x = succ y (case 2) for some natural number y,cases x with y,cases x with y,"case zero
hx : 0 ≤ 2
⊢ 0 = 0 ∨ 0 = 1 ∨ 0 = 2
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero
hx : 0 ≤ 2
⊢ 0 = 0 ∨ 0 = 1 ∨ 0 = 2
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_2,-- 0 = 0 ∨ 0 = 1 ∨ 0 = 2 -> 0 = 0,left,left,"case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_2,-- lhs = rhs,rw [← lhs_eq_rhs],rfl,"case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",error,No,No,No
le_two,le_two_dev_2,-- y = 0 (case 1) or y = succ z (case 2) for some natural number z,cases y with z,cases y with z,"case succ.zero
hx : succ 0 ≤ 2
⊢ succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",error,Yes,No,No
le_two,le_two_dev_2,-- succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2 -> succ 0 = 1 ∨ succ 0 = _dev_2,right,right,"case succ.zero.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",error,Yes,No,No
le_two,le_two_dev_2,-- succ 0 = 1 ∨ succ 0 = 2 -> succ 0 = _dev_1,left,left,"case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",error,Yes,No,No
le_two,le_two_dev_2,-- succ 0 = 1 -> succ 0 = succ 0,exact rfl,rw [one_eq_succ_zero],"case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = succ 0
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",error,No,No,No
le_two,le_two_dev_2,-- lhs = rhs,rw [← lhs_eq_rhs],rfl,"case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",error,No,No,No
le_two,le_two_dev_2,-- succ (succ z) ≤ 2 -> succ (succ z) ≤ succ 1 -> succ (succ z) ≤ succ (succ 0); ... = 0 ∨ ... = 1 ∨ ... = 2 -> ... = 0 ∨ ... = 1 ∨ ... = succ 1 -> ... = 0 ∨ ... = succ 0 ∨ ... = succ (succ 0),"rw [two_eq_succ_one, one_eq_succ_zero] at hx ⊢","rw [two_eq_succ_one, one_eq_succ_zero] at hx ⊢","case succ.succ
z : ℕ
hx : succ (succ z) ≤ succ (succ 0)
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
",error,Yes,No,No
le_two,le_two_dev_2,-- succ (succ z) ≤ succ (succ 0) -> succ z ≤ succ 0,apply succ_le_succ,apply succ_le_succ at hx,"case succ.succ
z : ℕ
hx : succ z ≤ succ 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
",error,No,No,No
le_two,le_two_dev_2,-- succ z ≤ succ 0 -> z ≤ 0,apply succ_le_succ,apply succ_le_succ at hx,"case succ.succ
z : ℕ
hx : z ≤ 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
",error,No,No,No
le_two,le_two_dev_2,-- z ≤ 0 -> z = 0,apply le_zero at hx,apply le_zero at hx,"case succ.succ
z : ℕ
hx : z = 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
",error,Yes,No,No
le_two,le_two_dev_2,-- succ (succ 0) = 0 ∨ succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0) -> succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0),right,right,"case succ.succ.h
z : ℕ
hx : z = 0
⊢ succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0)
",error,Yes,No,No
le_two,le_two_dev_2,-- lhs = rhs,rw [← lhs_eq_rhs],rfl,,error,No,Yes,Yes
World Name,Theorem Name,Natural Language,Predicted Formalization,True Tactic,True Goal State,Predicted Goal State,Tactics Match,Is Incorrect Tactic,Correctly Identified As Wrong
zero_pow_succ,zero_pow_succ_dev_2,"-- We can use induction on m. For the base case, we want to show that 0^succ(0) = 0.","rw [pow_succ, mul_zero]",induction m with h hd,"case zero
⊢ 0 ^ succ 0 = 0
case succ
h : ℕ
hd : 0 ^ succ h = 0
⊢ 0 ^ succ (succ h) = 0
","m : ℕ
⊢ 0 = 0
",No,No,Yes
World Name,Theorem Name,Natural Language,Predicted Formalization,True Tactic,True Goal State,Predicted Goal State,Tactics Match,Is Incorrect Tactic,Correctly Identified As Wrong
succ_eq_add_one,succ_eq_add_one_dev_1,-- Rewrite on both RHS and LHS making n -> n + 0,rw [add_zero],rw [← add_zero n],"n : ℕ
⊢ succ (n + 0) = n + 0 + 1
",error,No,No,No
succ_eq_add_one,succ_eq_add_one_dev_1,-- Rewrite on RHS making n + 0 + succ(0) -> succ(n+0+0),rw [add_succ],rw [add_succ],"n : ℕ
⊢ succ (n + 0) = succ (n + 0 + 0)
",error,Yes,Yes,Yes
succ_eq_add_one,succ_eq_add_one_dev_1,"-- succ(n+0) = succ(n+0), QED",rfl,rfl,,error,Yes,Yes,Yes
succ_eq_add_one,succ_eq_add_one_dev_2,-- Rewrite RHS 1 -> succ(0),rw [one_eq_succ_zero],rw [one_eq_succ_zero],"n : ℕ
⊢ succ n = n + succ 0
","n : ℕ
⊢ succ n = n + succ 0
",Yes,No,Yes
succ_eq_add_one,succ_eq_add_one_dev_2,-- Rewrite both RHS and LHS n -> n + 0,rw [add_zero],rw [← add_zero n],"n : ℕ
⊢ succ (n + 0) = n + 0 + succ 0
",error,No,No,No
succ_eq_add_one,succ_eq_add_one_dev_2,-- Rewrite RHS n + 0 + succ(0) -> succ(n + 0 + 0),rw [add_succ],rw [add_succ],"n : ℕ
⊢ succ (n + 0) = succ (n + 0 + 0)
",error,Yes,No,No
succ_eq_add_one,succ_eq_add_one_dev_2,"-- succ(n) = succ(n), QED",rfl,rfl,,error,Yes,Yes,Yes
add_right_eq_zero,add_right_eq_zero_dev_1,"-- We have two cases: b = 0, or b = succ d for some natural number d.",cases b with d,cases b with d,"case zero
a : ℕ
⊢ a + 0 = 0 → a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case zero
a : ℕ
⊢ a + 0 = 0 → a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_1,"-- In the former case, we must show that a + 0 = 0 → a = 0, so we start by assuming that a + 0 = 0.",intro h,intro h,"case zero
a : ℕ
h : a + 0 = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case zero
a : ℕ
h : a + 0 = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_1,-- We apply the theorem that n + 0 = n change a + 0 = 0 into a = 0.,rw [add_zero] at h,rw [add_zero] at h,"case zero
a : ℕ
h : a = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case zero
a : ℕ
h : a = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_1,"-- So, a = 0, which concludes this case of the theorem.",exact h,exact h,"case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_1,"-- In the latter case, we must show that a + succ d = 0 → a = 0, so we start by assuming that a + succ d = 0.",intro h,intro h,"case succ
a d : ℕ
h : a + succ d = 0
⊢ a = 0
","case succ
a d : ℕ
h : a + succ d = 0
⊢ a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_1,"-- By the symmetry of equality, we have that 0 = succ (a + d).",symm at h,symm at h,"case succ
a d : ℕ
h : 0 = succ (a + d)
⊢ a = 0
","case succ
a d : ℕ
h : 0 = a + succ d
⊢ a = 0
",Yes,Yes,No
add_right_eq_zero,add_right_eq_zero_dev_1,"-- Since a contradiction/falsehood implies anything, we are done.",exact false.elim h,cases h,,error,No,Yes,Yes
add_right_eq_zero,add_right_eq_zero_dev_2,-- either b = 0 or b = succ d for some natural number d,cases b with d,cases b with d,"case zero
a : ℕ
⊢ a + 0 = 0 → a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case zero
a : ℕ
⊢ a + 0 = 0 → a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_2,-- (case 1) assume a + 0 = 0,intro h,intro h,"case zero
a : ℕ
h : a + 0 = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case zero
a : ℕ
h : a + 0 = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_2,-- a + 0 = 0 -> a = 0,rw [add_zero] at h,rw [add_zero] at h,"case zero
a : ℕ
h : a = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case zero
a : ℕ
h : a = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_2,"-- a = 0, as desired",exact h,exact h,"case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_2,-- succ (a + d) = 0 -> 0 = succ (a + d),symm at h,symm at h,"case succ
a d : ℕ
h : 0 = succ (a + d)
⊢ a = 0
",error,Yes,Yes,Yes
add_right_eq_zero,add_right_eq_zero_dev_2,-- 0 = succ (a + d) -> False,apply zero_ne_succ,apply zero_ne_succ at h,"case succ
a d : ℕ
h : False
⊢ a = 0
",error,No,Yes,Yes
add_right_eq_zero,add_right_eq_zero_dev_2,-- False -> anything,exact false.elim,cases h,,error,No,Yes,Yes
World Name,Theorem Name,Natural Language,Predicted Formalization,True Tactic,True Goal State,Predicted Goal State,Tactics Match,Is Incorrect Tactic,Correctly Identified As Wrong
zero_add,zero_add__dev_1,-- Induct on n,induction n with d hd,induction n with d hd,"case zero
⊢ 0 + 0 = 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
","case zero
⊢ 0 + 0 = 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
",Yes,No,Yes
zero_add,zero_add__dev_1,-- substitute 0 -> 0 + 0 into the RHS giving us 0 + 0 = 0 + 0,rw [add_zero],nth_rewrite 3 [← add_zero 0],"case zero
⊢ 0 + 0 = 0 + 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
","case zero
⊢ 0 = 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
",No,No,Yes
zero_add,zero_add__dev_1,"-- 0 + 0 = 0 + 0, completing base case",rw [add_zero],rfl,"case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
",error,No,No,No
zero_add,zero_add__dev_1,"-- succ d = succ d, QED",rfl,rfl,,error,Yes,Yes,Yes
zero_add,zero_add__dev_2,-- Begin by initiating induction on n,induction n with d hd,induction n with d hd,"case zero
⊢ 0 + 0 = 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
","case zero
⊢ 0 + 0 = 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
",Yes,No,Yes
zero_add,zero_add__dev_2,-- Using the properties of addition by 0 we can rewrite 0 + 0 to 0 on the LHS,rw [add_zero],rw [add_zero],"case zero
⊢ 0 = 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
","case zero
⊢ 0 = 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
",Yes,No,Yes
zero_add,zero_add__dev_2,"-- Since both sides are equal, we are done with the base case",rfl,rfl,"case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
","case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
",Yes,No,Yes
zero_add,zero_add__dev_2,"-- Since both sides are equal, we are done with the proof",rfl,rfl,,error,Yes,Yes,Yes
