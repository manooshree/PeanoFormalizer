World Name,Theorem Name,Natural Language,Predicted Formalization,True Tactic,True Goal State,Predicted Goal State,Tactics Match,Is Incorrect Tactic,Correctly Identified As Wrong
exact_2,exact_2_dev_1,-- We simplify the hypothesis of 0 + x = 0 + y + 2 to x = 0 + x + 2.,rw [zero_add] at h,rw [zero_add] at h,"y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
","y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
",Yes,No,Yes
exact_2,exact_2_dev_2,-- 0 + x = 0 + y + 2 -> x = 0 + y + 2,rw [zero_add] at h,rw [zero_add] at h,"y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
","y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
",Yes,No,Yes
World Name,Theorem Name,Natural Language,Predicted Formalization,True Tactic,True Goal State,Predicted Goal State,Tactics Match,Is Incorrect Tactic,Correctly Identified As Wrong
zero_mul,zero_mul_dev_1,-- Proof by induction on m with base case 0 * 0 = 0 and inductive step 0 * d + 1 = 0,induction m with d hd,induction m with d hd,"case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
","case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",Yes,No,Yes
zero_mul,zero_mul_dev_1,-- First prove base case. Simplify LHS 0 * 0 to 0,rw [mul_zero],rw [mul_zero],"case zero
⊢ 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
","case zero
⊢ 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",Yes,No,Yes
zero_mul,zero_mul_dev_1,-- Simplify the LHS 0 * d + 0 to 0 + 0 using the definition of addition,rw [add_zero],rw [add_zero],"case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * d = 0
",error,Yes,Yes,Yes
zero_mul,zero_mul_dev_1,-- This is exactly the inductive hypothesis so we can complete the proof.,rfl,exact hd,,error,No,Yes,Yes
zero_mul,zero_mul_dev_2,-- Proof by induction on m with base case 0 * 0 = 0 and inductive step 0 * d + 1 = 0,induction m with d hd,induction m with d hd,"case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
","case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",Yes,No,Yes
zero_mul,zero_mul_dev_2,-- That proves the base case.,rfl,rfl,"case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",error,Yes,Yes,Yes
zero_mul,zero_mul_dev_2,-- This is exactly the inductive hypothesis so we can complete the proof.,rfl,exact hd,,error,No,Yes,Yes
World Name,Theorem Name,Natural Language,Predicted Formalization,True Tactic,True Goal State,Predicted Goal State,Tactics Match,Is Incorrect Tactic,Correctly Identified As Wrong
mul_left_ne_zero,mul_left_ne_zero__dev_1,-- Assume that b equals 0.,intro hd,intro hb,"a b : ℕ
h : a * b ≠ 0
hb : b = 0
⊢ False
","a b : ℕ
h : a * b ≠ 0
hd : b = 0
⊢ False
",No,No,Yes
mul_left_ne_zero,mul_left_ne_zero__dev_1,-- We use reflexivity to prove the goal of 0 = 0.,rfl,rfl,,error,Yes,Yes,Yes
mul_left_ne_zero,mul_left_ne_zero__dev_2,-- Assume that b equals 0.,intro hd,intro hd,"a b : ℕ
h : a * b ≠ 0
hd : b = 0
⊢ False
","a b : ℕ
h : a * b ≠ 0
hd : b = 0
⊢ False
",Yes,No,Yes
mul_left_ne_zero,mul_left_ne_zero__dev_2,-- We have 0 != 0 which is a contradiction.,exact h rfl,tauto,,error,No,Yes,Yes
World Name,Theorem Name,Natural Language,Predicted Formalization,True Tactic,True Goal State,Predicted Goal State,Tactics Match,Is Incorrect Tactic,Correctly Identified As Wrong
add_left_comm,add_left_comm_dev_1,"-- By associativity of addition, can change a + (b + c) into (a + b) + c",rw [add_assoc],rw [← add_assoc],"a b c : ℕ
⊢ a + b + c = b + (a + c)
",error,No,No,No
add_left_comm,add_left_comm_dev_1,"-- So we just need to show b + (a + c) = b + (a + c), which is true by reflexivity.",rfl,rfl,,error,Yes,Yes,Yes
add_left_comm,add_left_comm_dev_2,-- a + (b + c) = b + (a + c) -> (a + b) + c = b + (a + c),rw [add_assoc],rw [← add_assoc],"a b c : ℕ
⊢ a + b + c = b + (a + c)
",error,No,No,No
add_left_comm,add_left_comm_dev_2,-- lhs = rhs,rw [add_assoc],rfl,,error,No,Yes,Yes
World Name,Theorem Name,Natural Language,Predicted Formalization,True Tactic,True Goal State,Predicted Goal State,Tactics Match,Is Incorrect Tactic,Correctly Identified As Wrong
le_two,le_two_dev_1,-- Either x = 0 or x = succ y for some natural number y.,cases x with y,cases x with y,"case zero
hx : 0 ≤ 2
⊢ 0 = 0 ∨ 0 = 1 ∨ 0 = 2
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero
hx : 0 ≤ 2
⊢ 0 = 0 ∨ 0 = 1 ∨ 0 = 2
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- In the former case, we need to show 0 = 0 ∨ 0 = 1 ∨ 0 = 2, and we choose to show 0 = 0.",left,left,"case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_1,-- This is clear by reflexivity.,rfl,rfl,"case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- In the latter case, either y = 0 or y = succ z for some natural number z.",cases y with z,cases y with z,"case succ.zero
hx : succ 0 ≤ 2
⊢ succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case succ.zero
hx : succ 0 ≤ 2
⊢ succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- In the former case, we must show succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2, and we choose to prove succ 0 = 1 ∨ succ 0 = _dev_2",right,right,"case succ.zero.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case succ.zero.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- To prove succ 0 = 1 ∨ succ 0 = 2, we choose to prove succ 0 = _dev_1",left,left,"case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- Rewriting using a theorem, need to show show succ 0 = succ 0.",rfl,rw [one_eq_succ_zero],"case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = succ 0
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",error,No,No,No
le_two,le_two_dev_1,-- This is clear by reflexivity.,rfl,rfl,"case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",error,Yes,No,No
le_two,le_two_dev_1,"-- In the latter case, we substitute 2 = succ 1 and 1 = succ 0 into what we know and what we have to show.","rw [two_eq_succ_one, one_eq_succ_zero] at hx ⊢","rw [two_eq_succ_one, one_eq_succ_zero] at hx ⊢","case succ.succ
z : ℕ
hx : succ (succ z) ≤ succ (succ 0)
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
",error,Yes,No,No
le_two,le_two_dev_1,"-- We know that succ (succ z) ≤ succ (succ 0), so usinig a theorem we know succ z ≤ succ 0.",apply succ_le_succ at hx,apply succ_le_succ at hx,"case succ.succ
z : ℕ
hx : succ z ≤ succ 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
",error,Yes,No,No
le_two,le_two_dev_1,"-- We know that succ z ≤ succ 0, so using a theorem we know that z ≤ 0.",apply succ_le_succ at hx,apply succ_le_succ at hx,"case succ.succ
z : ℕ
hx : z ≤ 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
",error,Yes,No,No
le_two,le_two_dev_1,"-- Since z ≤ 0, using a theorem, z = 0.",apply le_zero at hx,apply le_zero at hx,"case succ.succ
z : ℕ
hx : z = 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
",error,Yes,No,No
le_two,le_two_dev_1,"-- So, we need to show that succ (succ 0) = 0 ∨ succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0), so we choose to show that succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0)",right,right,"case succ.succ.h
z : ℕ
hx : z = 0
⊢ succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0)
",error,Yes,No,No
le_two,le_two_dev_1,"-- But LHS = RHS, so this follows by reflexivity.",rfl,rfl,,error,Yes,Yes,Yes
le_two,le_two_dev_2,-- x = 0 (case 1) or x = succ y (case 2) for some natural number y,cases x with y,cases x with y,"case zero
hx : 0 ≤ 2
⊢ 0 = 0 ∨ 0 = 1 ∨ 0 = 2
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero
hx : 0 ≤ 2
⊢ 0 = 0 ∨ 0 = 1 ∨ 0 = 2
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_2,-- 0 = 0 ∨ 0 = 1 ∨ 0 = 2 -> 0 = 0,"left, rfl",left,"case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,No,Yes
le_two,le_two_dev_2,-- lhs = rhs,rw [one_eq_succ_zero],rfl,"case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,No,Yes
le_two,le_two_dev_2,-- y = 0 (case 1) or y = succ z (case 2) for some natural number z,cases y with z,cases y with z,"case succ.zero
hx : succ 0 ≤ 2
⊢ succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_2,-- succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2 -> succ 0 = 1 ∨ succ 0 = _dev_2,right,right,"case succ.zero.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_2,-- succ 0 = 1 ∨ succ 0 = 2 -> succ 0 = _dev_1,rw [one_eq_succ_zero],left,"case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,No,Yes
le_two,le_two_dev_2,-- succ 0 = 1 -> succ 0 = succ 0,rfl,rw [one_eq_succ_zero],"case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = succ 0
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,No,Yes
le_two,le_two_dev_2,-- lhs = rhs,rw [one_eq_succ_zero],rfl,"case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,No,Yes
le_two,le_two_dev_2,-- succ (succ z) ≤ 2 -> succ (succ z) ≤ succ 1 -> succ (succ z) ≤ succ (succ 0); ... = 0 ∨ ... = 1 ∨ ... = 2 -> ... = 0 ∨ ... = 1 ∨ ... = succ 1 -> ... = 0 ∨ ... = succ 0 ∨ ... = succ (succ 0),"rw [two_eq_succ_one, one_eq_succ_zero] at hx ⊢","rw [two_eq_succ_one, one_eq_succ_zero] at hx ⊢","case succ.succ
z : ℕ
hx : succ (succ z) ≤ succ (succ 0)
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_2,-- succ (succ z) ≤ succ (succ 0) -> succ z ≤ succ 0,apply succ_le_succ at hx,apply succ_le_succ at hx,"case succ.succ
z : ℕ
hx : succ z ≤ succ 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_2,-- succ z ≤ succ 0 -> z ≤ 0,apply succ_le_succ,apply succ_le_succ at hx,"case succ.succ
z : ℕ
hx : z ≤ 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,No,Yes
le_two,le_two_dev_2,-- z ≤ 0 -> z = 0,apply le_zero,apply le_zero at hx,"case succ.succ
z : ℕ
hx : z = 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,No,Yes
le_two,le_two_dev_2,-- succ (succ 0) = 0 ∨ succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0) -> succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0),right,right,"case succ.succ.h
z : ℕ
hx : z = 0
⊢ succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
exact_2,exact_2_dev_1,-- We simplify the hypothesis of 0 + x = 0 + y + 2 to x = 0 + x + 2.,rw [zero_add] at h,rw [zero_add] at h,"y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
","y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
",Yes,No,Yes
exact_2,exact_2_dev_2,-- 0 + x = 0 + y + 2 -> x = 0 + y + 2,rw [zero_add] at h,rw [zero_add] at h,"y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
","y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
",Yes,No,Yes
zero_mul,zero_mul_dev_1,-- Proof by induction on m with base case 0 * 0 = 0 and inductive step 0 * d + 1 = 0,induction m with d hd,induction m with d hd,"case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
","case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",Yes,No,Yes
zero_mul,zero_mul_dev_1,-- First prove base case. Simplify LHS 0 * 0 to 0,rw [mul_zero],rw [mul_zero],"case zero
⊢ 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
","case zero
⊢ 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",Yes,No,Yes
zero_mul,zero_mul_dev_1,-- Simplify the LHS 0 * d + 0 to 0 + 0 using the definition of addition,rw [add_zero],rw [add_zero],"case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * d = 0
",error,Yes,Yes,Yes
zero_mul,zero_mul_dev_1,-- This is exactly the inductive hypothesis so we can complete the proof.,rfl,exact hd,,error,No,Yes,Yes
zero_mul,zero_mul_dev_2,-- Proof by induction on m with base case 0 * 0 = 0 and inductive step 0 * d + 1 = 0,induction m with d hd,induction m with d hd,"case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
","case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",Yes,No,Yes
zero_mul,zero_mul_dev_2,-- That proves the base case.,rfl,rfl,"case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",error,Yes,Yes,Yes
zero_mul,zero_mul_dev_2,-- This is exactly the inductive hypothesis so we can complete the proof.,rfl,exact hd,,error,No,Yes,Yes
mul_left_ne_zero,mul_left_ne_zero__dev_1,-- Assume that b equals 0.,intro hd,intro hb,"a b : ℕ
h : a * b ≠ 0
hb : b = 0
⊢ False
","a b : ℕ
h : a * b ≠ 0
hd : b = 0
⊢ False
",No,No,Yes
mul_left_ne_zero,mul_left_ne_zero__dev_1,-- We use reflexivity to prove the goal of 0 = 0.,rfl,rfl,,error,Yes,Yes,Yes
mul_left_ne_zero,mul_left_ne_zero__dev_2,-- Assume that b equals 0.,intro hd,intro hd,"a b : ℕ
h : a * b ≠ 0
hd : b = 0
⊢ False
","a b : ℕ
h : a * b ≠ 0
hd : b = 0
⊢ False
",Yes,No,Yes
mul_left_ne_zero,mul_left_ne_zero__dev_2,-- We have 0 != 0 which is a contradiction.,trivial,tauto,,error,No,Yes,Yes
add_left_comm,add_left_comm_dev_1,"-- By associativity of addition, can change a + (b + c) into (a + b) + c",rw [add_assoc],rw [← add_assoc],"a b c : ℕ
⊢ a + b + c = b + (a + c)
",error,No,No,No
add_left_comm,add_left_comm_dev_1,"-- So we just need to show b + (a + c) = b + (a + c), which is true by reflexivity.",rfl,rfl,,error,Yes,Yes,Yes
add_left_comm,add_left_comm_dev_2,-- a + (b + c) = b + (a + c) -> (a + b) + c = b + (a + c),rw [add_assoc],rw [← add_assoc],"a b c : ℕ
⊢ a + b + c = b + (a + c)
",error,No,No,No
add_left_comm,add_left_comm_dev_2,-- lhs = rhs,rw [add_assoc],rfl,,error,No,Yes,Yes
le_two,le_two_dev_1,-- Either x = 0 or x = succ y for some natural number y.,cases x with y,cases x with y,"case zero
hx : 0 ≤ 2
⊢ 0 = 0 ∨ 0 = 1 ∨ 0 = 2
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero
hx : 0 ≤ 2
⊢ 0 = 0 ∨ 0 = 1 ∨ 0 = 2
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- In the former case, we need to show 0 = 0 ∨ 0 = 1 ∨ 0 = 2, and we choose to show 0 = 0.",left,left,"case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_1,-- This is clear by reflexivity.,rfl,rfl,"case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- In the latter case, either y = 0 or y = succ z for some natural number z.",cases y with z,cases y with z,"case succ.zero
hx : succ 0 ≤ 2
⊢ succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case succ.zero
hx : succ 0 ≤ 2
⊢ succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- In the former case, we must show succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2, and we choose to prove succ 0 = 1 ∨ succ 0 = _dev_2",right,right,"case succ.zero.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case succ.zero.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- To prove succ 0 = 1 ∨ succ 0 = 2, we choose to prove succ 0 = _dev_1",left,left,"case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- Rewriting using a theorem, need to show show succ 0 = succ 0.",rfl,rw [one_eq_succ_zero],"case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = succ 0
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",error,No,No,No
le_two,le_two_dev_1,-- This is clear by reflexivity.,rfl,rfl,"case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",error,Yes,No,No
le_two,le_two_dev_1,"-- In the latter case, we substitute 2 = succ 1 and 1 = succ 0 into what we know and what we have to show.","rw [two_eq_succ_one, one_eq_succ_zero] at hx ⊢","rw [two_eq_succ_one, one_eq_succ_zero] at hx ⊢","case succ.succ
z : ℕ
hx : succ (succ z) ≤ succ (succ 0)
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
",error,Yes,No,No
le_two,le_two_dev_1,"-- We know that succ (succ z) ≤ succ (succ 0), so usinig a theorem we know succ z ≤ succ 0.",apply succ_le_succ at hx,apply succ_le_succ at hx,"case succ.succ
z : ℕ
hx : succ z ≤ succ 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
",error,Yes,No,No
le_two,le_two_dev_1,"-- We know that succ z ≤ succ 0, so using a theorem we know that z ≤ 0.",apply succ_le_succ at hx,apply succ_le_succ at hx,"case succ.succ
z : ℕ
hx : z ≤ 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
",error,Yes,No,No
le_two,le_two_dev_1,"-- Since z ≤ 0, using a theorem, z = 0.",apply le_zero at hx,apply le_zero at hx,"case succ.succ
z : ℕ
hx : z = 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
",error,Yes,No,No
le_two,le_two_dev_1,"-- So, we need to show that succ (succ 0) = 0 ∨ succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0), so we choose to show that succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0)",right,right,"case succ.succ.h
z : ℕ
hx : z = 0
⊢ succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0)
",error,Yes,No,No
le_two,le_two_dev_1,"-- But LHS = RHS, so this follows by reflexivity.",rfl,rfl,,error,Yes,Yes,Yes
le_two,le_two_dev_2,-- x = 0 (case 1) or x = succ y (case 2) for some natural number y,cases x with y,cases x with y,"case zero
hx : 0 ≤ 2
⊢ 0 = 0 ∨ 0 = 1 ∨ 0 = 2
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero
hx : 0 ≤ 2
⊢ 0 = 0 ∨ 0 = 1 ∨ 0 = 2
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_2,-- 0 = 0 ∨ 0 = 1 ∨ 0 = 2 -> 0 = 0,"left
rfl",left,"case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,No,Yes
le_two,le_two_dev_2,-- lhs = rhs,rw [← hx],rfl,"case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,No,Yes
le_two,le_two_dev_2,-- y = 0 (case 1) or y = succ z (case 2) for some natural number z,cases y with z,cases y with z,"case succ.zero
hx : succ 0 ≤ 2
⊢ succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_2,-- succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2 -> succ 0 = 1 ∨ succ 0 = _dev_2,right,right,"case succ.zero.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_2,-- succ 0 = 1 ∨ succ 0 = 2 -> succ 0 = _dev_1,left,left,"case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_2,-- succ 0 = 1 -> succ 0 = succ 0,rfl,rw [one_eq_succ_zero],"case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = succ 0
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,No,Yes
le_two,le_two_dev_2,-- lhs = rhs,rw [← hx],rfl,"case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,No,Yes
le_two,le_two_dev_2,-- succ (succ z) ≤ 2 -> succ (succ z) ≤ succ 1 -> succ (succ z) ≤ succ (succ 0); ... = 0 ∨ ... = 1 ∨ ... = 2 -> ... = 0 ∨ ... = 1 ∨ ... = succ 1 -> ... = 0 ∨ ... = succ 0 ∨ ... = succ (succ 0),"rw [le_succ_self, le_two]","rw [two_eq_succ_one, one_eq_succ_zero] at hx ⊢","case succ.succ
z : ℕ
hx : succ (succ z) ≤ succ (succ 0)
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,No,Yes
le_two,le_two_dev_2,-- succ (succ z) ≤ succ (succ 0) -> succ z ≤ succ 0,apply succ_le_succ at hx,apply succ_le_succ at hx,"case succ.succ
z : ℕ
hx : succ z ≤ succ 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_2,-- succ z ≤ succ 0 -> z ≤ 0,apply succ_le_succ,apply succ_le_succ at hx,"case succ.succ
z : ℕ
hx : z ≤ 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,No,Yes
le_two,le_two_dev_2,-- z ≤ 0 -> z = 0,apply le_zero,apply le_zero at hx,"case succ.succ
z : ℕ
hx : z = 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,No,Yes
le_two,le_two_dev_2,-- succ (succ 0) = 0 ∨ succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0) -> succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0),right,right,"case succ.succ.h
z : ℕ
hx : z = 0
⊢ succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_2,-- lhs = rhs,rw [← hx],rfl,,"case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,Yes,No
World Name,Theorem Name,Natural Language,Predicted Formalization,True Tactic,True Goal State,Predicted Goal State,Tactics Match,Is Incorrect Tactic,Correctly Identified As Wrong
zero_pow_succ,zero_pow_succ_dev_2,"-- We can use induction on m. For the base case, we want to show that 0^succ(0) = 0.",induction m with d hd,induction m with h hd,"case zero
⊢ 0 ^ succ 0 = 0
case succ
h : ℕ
hd : 0 ^ succ h = 0
⊢ 0 ^ succ (succ h) = 0
","case zero
⊢ 0 ^ succ 0 = 0
case succ
d : ℕ
hd : 0 ^ succ d = 0
⊢ 0 ^ succ (succ d) = 0
",No,No,Yes
World Name,Theorem Name,Natural Language,Predicted Formalization,True Tactic,True Goal State,Predicted Goal State,Tactics Match,Is Incorrect Tactic,Correctly Identified As Wrong
succ_eq_add_one,succ_eq_add_one_dev_1,-- Rewrite on both RHS and LHS making n -> n + 0,rw [add_zero],rw [← add_zero n],"n : ℕ
⊢ succ (n + 0) = n + 0 + 1
",error,No,No,No
succ_eq_add_one,succ_eq_add_one_dev_1,-- Rewrite on RHS making n + 0 + succ(0) -> succ(n+0+0),rw [add_succ],rw [add_succ],"n : ℕ
⊢ succ (n + 0) = succ (n + 0 + 0)
",error,Yes,Yes,Yes
succ_eq_add_one,succ_eq_add_one_dev_1,"-- succ(n+0) = succ(n+0), QED",rfl,rfl,,error,Yes,Yes,Yes
succ_eq_add_one,succ_eq_add_one_dev_2,-- Rewrite RHS 1 -> succ(0),rw [one_eq_succ_zero],rw [one_eq_succ_zero],"n : ℕ
⊢ succ n = n + succ 0
","n : ℕ
⊢ succ n = n + succ 0
",Yes,No,Yes
succ_eq_add_one,succ_eq_add_one_dev_2,-- Rewrite both RHS and LHS n -> n + 0,rw [add_zero],rw [← add_zero n],"n : ℕ
⊢ succ (n + 0) = n + 0 + succ 0
",error,No,No,No
succ_eq_add_one,succ_eq_add_one_dev_2,-- Rewrite RHS n + 0 + succ(0) -> succ(n + 0 + 0),rw [add_succ],rw [add_succ],"n : ℕ
⊢ succ (n + 0) = succ (n + 0 + 0)
",error,Yes,No,No
succ_eq_add_one,succ_eq_add_one_dev_2,"-- succ(n) = succ(n), QED",rfl,rfl,,error,Yes,Yes,Yes
World Name,Theorem Name,Natural Language,Predicted Formalization,True Tactic,True Goal State,Predicted Goal State,Tactics Match,Is Incorrect Tactic,Correctly Identified As Wrong
add_right_eq_zero,add_right_eq_zero_dev_1,"-- We have two cases: b = 0, or b = succ d for some natural number d.",cases b with d,cases b with d,"case zero
a : ℕ
⊢ a + 0 = 0 → a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case zero
a : ℕ
⊢ a + 0 = 0 → a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_1,"-- In the former case, we must show that a + 0 = 0 → a = 0, so we start by assuming that a + 0 = 0.",intro h,intro h,"case zero
a : ℕ
h : a + 0 = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case zero
a : ℕ
h : a + 0 = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_1,-- We apply the theorem that n + 0 = n change a + 0 = 0 into a = 0.,rw [add_zero] at h,rw [add_zero] at h,"case zero
a : ℕ
h : a = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case zero
a : ℕ
h : a = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_1,"-- So, a = 0, which concludes this case of the theorem.",exact h,exact h,"case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_1,"-- In the latter case, we must show that a + succ d = 0 → a = 0, so we start by assuming that a + succ d = 0.",intro h,intro h,"case succ
a d : ℕ
h : a + succ d = 0
⊢ a = 0
","case succ
a d : ℕ
h : a + succ d = 0
⊢ a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_1,"-- By the symmetry of equality, we have that 0 = succ (a + d).",symm at h,symm at h,"case succ
a d : ℕ
h : 0 = succ (a + d)
⊢ a = 0
","case succ
a d : ℕ
h : 0 = a + succ d
⊢ a = 0
",Yes,Yes,No
add_right_eq_zero,add_right_eq_zero_dev_1,"-- Since a contradiction/falsehood implies anything, we are done.",exact h,cases h,,error,No,Yes,Yes
add_right_eq_zero,add_right_eq_zero_dev_2,-- either b = 0 or b = succ d for some natural number d,cases b with d,cases b with d,"case zero
a : ℕ
⊢ a + 0 = 0 → a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case zero
a : ℕ
⊢ a + 0 = 0 → a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_2,-- (case 1) assume a + 0 = 0,intro h,intro h,"case zero
a : ℕ
h : a + 0 = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case zero
a : ℕ
h : a + 0 = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_2,-- a + 0 = 0 -> a = 0,exact h,rw [add_zero] at h,"case zero
a : ℕ
h : a = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",error,No,No,No
add_right_eq_zero,add_right_eq_zero_dev_2,"-- a = 0, as desired",exact h,exact h,"case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",error,Yes,No,No
add_right_eq_zero,add_right_eq_zero_dev_2,-- succ (a + d) = 0 -> 0 = succ (a + d),symm at h,symm at h,"case succ
a d : ℕ
h : 0 = succ (a + d)
⊢ a = 0
",error,Yes,Yes,Yes
add_right_eq_zero,add_right_eq_zero_dev_2,-- 0 = succ (a + d) -> False,apply zero_ne_succ,apply zero_ne_succ at h,"case succ
a d : ℕ
h : False
⊢ a = 0
",error,No,Yes,Yes
add_right_eq_zero,add_right_eq_zero_dev_2,-- False -> anything,trivial,cases h,,error,No,Yes,Yes
World Name,Theorem Name,Natural Language,Predicted Formalization,True Tactic,True Goal State,Predicted Goal State,Tactics Match,Is Incorrect Tactic,Correctly Identified As Wrong
zero_add,zero_add__dev_1,-- Induct on n,induction n with d hd,induction n with d hd,"case zero
⊢ 0 + 0 = 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
","case zero
⊢ 0 + 0 = 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
",Yes,No,Yes
zero_add,zero_add__dev_1,-- substitute 0 -> 0 + 0 into the RHS giving us 0 + 0 = 0 + 0,rw [add_zero],nth_rewrite 3 [← add_zero 0],"case zero
⊢ 0 + 0 = 0 + 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
","case zero
⊢ 0 = 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
",No,No,Yes
zero_add,zero_add__dev_1,"-- 0 + 0 = 0 + 0, completing base case",rfl,rfl,"case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
","case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
",Yes,No,Yes
zero_add,zero_add__dev_1,"-- succ d = succ d, QED",rfl,rfl,,error,Yes,Yes,Yes
zero_add,zero_add__dev_2,-- Begin by initiating induction on n,induction n with d hd,induction n with d hd,"case zero
⊢ 0 + 0 = 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
","case zero
⊢ 0 + 0 = 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
",Yes,No,Yes
zero_add,zero_add__dev_2,-- Using the properties of addition by 0 we can rewrite 0 + 0 to 0 on the LHS,rw [add_zero],rw [add_zero],"case zero
⊢ 0 = 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
","case zero
⊢ 0 = 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
",Yes,No,Yes
zero_add,zero_add__dev_2,"-- Since both sides are equal, we are done with the base case",rfl,rfl,"case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
","case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
",Yes,No,Yes
zero_add,zero_add__dev_2,"-- Since both sides are equal, we are done with the proof",rfl,rfl,,error,Yes,Yes,Yes
exact_2,exact_2_dev_1,-- We simplify the hypothesis of 0 + x = 0 + y + 2 to x = 0 + x + 2.,rw [zero_add] at h,rw [zero_add] at h,"y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
","y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
",Yes,No,Yes
exact_2,exact_2_dev_2,-- 0 + x = 0 + y + 2 -> x = 0 + y + 2,rw [zero_add] at h,rw [zero_add] at h,"y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
","y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
",Yes,No,Yes
zero_mul,zero_mul_dev_1,-- Proof by induction on m with base case 0 * 0 = 0 and inductive step 0 * d + 1 = 0,induction m with d hd,induction m with d hd,"case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
","case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",Yes,No,Yes
zero_mul,zero_mul_dev_1,-- First prove base case. Simplify LHS 0 * 0 to 0,rw [mul_zero],rw [mul_zero],"case zero
⊢ 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
","case zero
⊢ 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",Yes,No,Yes
zero_mul,zero_mul_dev_1,-- Simplify the LHS 0 * d + 0 to 0 + 0 using the definition of addition,rw [add_zero],rw [add_zero],"case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * d = 0
",error,Yes,Yes,Yes
zero_mul,zero_mul_dev_1,-- This is exactly the inductive hypothesis so we can complete the proof.,rfl,exact hd,,error,No,Yes,Yes
zero_mul,zero_mul_dev_2,-- Proof by induction on m with base case 0 * 0 = 0 and inductive step 0 * d + 1 = 0,induction m with d hd,induction m with d hd,"case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
","case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",Yes,No,Yes
exact_2,exact_2_dev_1,-- We simplify the hypothesis of 0 + x = 0 + y + 2 to x = 0 + x + 2.,rw [zero_add] at h,rw [zero_add] at h,"y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
","y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
",Yes,No,Yes
exact_2,exact_2_dev_2,-- 0 + x = 0 + y + 2 -> x = 0 + y + 2,rw [zero_add] at h,rw [zero_add] at h,"y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
","y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
",Yes,No,Yes
zero_mul,zero_mul_dev_1,-- Proof by induction on m with base case 0 * 0 = 0 and inductive step 0 * d + 1 = 0,induction m with d hd,induction m with d hd,"case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
","case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",Yes,No,Yes
zero_mul,zero_mul_dev_1,-- First prove base case. Simplify LHS 0 * 0 to 0,rw [mul_zero],rw [mul_zero],"case zero
⊢ 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
","case zero
⊢ 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",Yes,No,Yes
zero_mul,zero_mul_dev_1,-- Simplify the LHS 0 * d + 0 to 0 + 0 using the definition of addition,rw [add_zero],rw [add_zero],"case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * d = 0
",error,Yes,Yes,Yes
zero_mul,zero_mul_dev_1,-- This is exactly the inductive hypothesis so we can complete the proof.,rfl,exact hd,,error,No,Yes,Yes
zero_mul,zero_mul_dev_2,-- Proof by induction on m with base case 0 * 0 = 0 and inductive step 0 * d + 1 = 0,induction m with d hd,induction m with d hd,"case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
","case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",Yes,No,Yes
zero_mul,zero_mul_dev_2,-- That proves the base case.,rfl,rfl,"case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",error,Yes,Yes,Yes
zero_mul,zero_mul_dev_2,-- This is exactly the inductive hypothesis so we can complete the proof.,rfl,exact hd,,error,No,Yes,Yes
mul_left_ne_zero,mul_left_ne_zero__dev_1,-- Assume that b equals 0.,intro hd,intro hb,"a b : ℕ
h : a * b ≠ 0
hb : b = 0
⊢ False
","a b : ℕ
h : a * b ≠ 0
hd : b = 0
⊢ False
",No,No,Yes
mul_left_ne_zero,mul_left_ne_zero__dev_1,-- We use reflexivity to prove the goal of 0 = 0.,rfl,rfl,,error,Yes,Yes,Yes
mul_left_ne_zero,mul_left_ne_zero__dev_2,-- Assume that b equals 0.,intro hd,intro hd,"a b : ℕ
h : a * b ≠ 0
hd : b = 0
⊢ False
","a b : ℕ
h : a * b ≠ 0
hd : b = 0
⊢ False
",Yes,No,Yes
mul_left_ne_zero,mul_left_ne_zero__dev_2,-- We have 0 != 0 which is a contradiction.,trivial,tauto,,error,No,Yes,Yes
add_left_comm,add_left_comm_dev_1,"-- By associativity of addition, can change a + (b + c) into (a + b) + c",rw [add_assoc],rw [← add_assoc],"a b c : ℕ
⊢ a + b + c = b + (a + c)
",error,No,No,No
add_left_comm,add_left_comm_dev_1,"-- So we just need to show b + (a + c) = b + (a + c), which is true by reflexivity.",rfl,rfl,,error,Yes,Yes,Yes
add_left_comm,add_left_comm_dev_2,-- a + (b + c) = b + (a + c) -> (a + b) + c = b + (a + c),rw [add_assoc],rw [← add_assoc],"a b c : ℕ
⊢ a + b + c = b + (a + c)
",error,No,No,No
add_left_comm,add_left_comm_dev_2,-- lhs = rhs,rw [add_assoc],rfl,,error,No,Yes,Yes
le_two,le_two_dev_1,-- Either x = 0 or x = succ y for some natural number y.,cases x with y,cases x with y,"case zero
hx : 0 ≤ 2
⊢ 0 = 0 ∨ 0 = 1 ∨ 0 = 2
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero
hx : 0 ≤ 2
⊢ 0 = 0 ∨ 0 = 1 ∨ 0 = 2
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- In the former case, we need to show 0 = 0 ∨ 0 = 1 ∨ 0 = 2, and we choose to show 0 = 0.",left,left,"case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_1,-- This is clear by reflexivity.,rfl,rfl,"case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- In the latter case, either y = 0 or y = succ z for some natural number z.",cases y with z,cases y with z,"case succ.zero
hx : succ 0 ≤ 2
⊢ succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case succ.zero
hx : succ 0 ≤ 2
⊢ succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- In the former case, we must show succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2, and we choose to prove succ 0 = 1 ∨ succ 0 = _dev_2",right,right,"case succ.zero.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case succ.zero.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- To prove succ 0 = 1 ∨ succ 0 = 2, we choose to prove succ 0 = _dev_1",left,left,"case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- Rewriting using a theorem, need to show show succ 0 = succ 0.",rfl,rw [one_eq_succ_zero],"case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = succ 0
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",error,No,No,No
le_two,le_two_dev_1,-- This is clear by reflexivity.,rfl,rfl,"case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",error,Yes,No,No
le_two,le_two_dev_1,"-- In the latter case, we substitute 2 = succ 1 and 1 = succ 0 into what we know and what we have to show.","rw [two_eq_succ_one, one_eq_succ_zero] at hx ⊢","rw [two_eq_succ_one, one_eq_succ_zero] at hx ⊢","case succ.succ
z : ℕ
hx : succ (succ z) ≤ succ (succ 0)
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
",error,Yes,No,No
le_two,le_two_dev_1,"-- We know that succ (succ z) ≤ succ (succ 0), so usinig a theorem we know succ z ≤ succ 0.",apply succ_le_succ at hx,apply succ_le_succ at hx,"case succ.succ
z : ℕ
hx : succ z ≤ succ 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
",error,Yes,No,No
le_two,le_two_dev_1,"-- We know that succ z ≤ succ 0, so using a theorem we know that z ≤ 0.",apply succ_le_succ at hx,apply succ_le_succ at hx,"case succ.succ
z : ℕ
hx : z ≤ 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
",error,Yes,No,No
le_two,le_two_dev_1,"-- Since z ≤ 0, using a theorem, z = 0.",apply le_zero at hx,apply le_zero at hx,"case succ.succ
z : ℕ
hx : z = 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
",error,Yes,No,No
le_two,le_two_dev_1,"-- So, we need to show that succ (succ 0) = 0 ∨ succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0), so we choose to show that succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0)",right,right,"case succ.succ.h
z : ℕ
hx : z = 0
⊢ succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0)
",error,Yes,No,No
le_two,le_two_dev_1,"-- But LHS = RHS, so this follows by reflexivity.",rfl,rfl,,error,Yes,Yes,Yes
le_two,le_two_dev_2,-- x = 0 (case 1) or x = succ y (case 2) for some natural number y,cases x with y,cases x with y,"case zero
hx : 0 ≤ 2
⊢ 0 = 0 ∨ 0 = 1 ∨ 0 = 2
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero
hx : 0 ≤ 2
⊢ 0 = 0 ∨ 0 = 1 ∨ 0 = 2
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_2,-- 0 = 0 ∨ 0 = 1 ∨ 0 = 2 -> 0 = 0,"left
rfl",left,"case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,No,Yes
le_two,le_two_dev_2,-- lhs = rhs,rw [← hx],rfl,"case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,No,Yes
le_two,le_two_dev_2,-- y = 0 (case 1) or y = succ z (case 2) for some natural number z,cases y with z,cases y with z,"case succ.zero
hx : succ 0 ≤ 2
⊢ succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_2,-- succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2 -> succ 0 = 1 ∨ succ 0 = _dev_2,right,right,"case succ.zero.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_2,-- succ 0 = 1 ∨ succ 0 = 2 -> succ 0 = _dev_1,left,left,"case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_2,-- succ 0 = 1 -> succ 0 = succ 0,rfl,rw [one_eq_succ_zero],"case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = succ 0
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,No,Yes
le_two,le_two_dev_2,-- lhs = rhs,rw [← hx],rfl,"case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,No,Yes
le_two,le_two_dev_2,-- succ (succ z) ≤ 2 -> succ (succ z) ≤ succ 1 -> succ (succ z) ≤ succ (succ 0); ... = 0 ∨ ... = 1 ∨ ... = 2 -> ... = 0 ∨ ... = 1 ∨ ... = succ 1 -> ... = 0 ∨ ... = succ 0 ∨ ... = succ (succ 0),"rw [le_succ_self, le_two]","rw [two_eq_succ_one, one_eq_succ_zero] at hx ⊢","case succ.succ
z : ℕ
hx : succ (succ z) ≤ succ (succ 0)
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,No,Yes
le_two,le_two_dev_2,-- succ (succ z) ≤ succ (succ 0) -> succ z ≤ succ 0,apply succ_le_succ at hx,apply succ_le_succ at hx,"case succ.succ
z : ℕ
hx : succ z ≤ succ 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_2,-- succ z ≤ succ 0 -> z ≤ 0,apply succ_le_succ,apply succ_le_succ at hx,"case succ.succ
z : ℕ
hx : z ≤ 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,No,Yes
le_two,le_two_dev_2,-- z ≤ 0 -> z = 0,apply le_zero,apply le_zero at hx,"case succ.succ
z : ℕ
hx : z = 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,No,Yes
le_two,le_two_dev_2,-- succ (succ 0) = 0 ∨ succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0) -> succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0),right,right,"case succ.succ.h
z : ℕ
hx : z = 0
⊢ succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_2,-- lhs = rhs,rw [← hx],rfl,,"case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,Yes,No
zero_pow_succ,zero_pow_succ_dev_2,"-- We can use induction on m. For the base case, we want to show that 0^succ(0) = 0.",induction m with d hd,induction m with h hd,"case zero
⊢ 0 ^ succ 0 = 0
case succ
h : ℕ
hd : 0 ^ succ h = 0
⊢ 0 ^ succ (succ h) = 0
","case zero
⊢ 0 ^ succ 0 = 0
case succ
d : ℕ
hd : 0 ^ succ d = 0
⊢ 0 ^ succ (succ d) = 0
",No,No,Yes
succ_eq_add_one,succ_eq_add_one_dev_1,-- Rewrite on both RHS and LHS making n -> n + 0,rw [add_zero],rw [← add_zero n],"n : ℕ
⊢ succ (n + 0) = n + 0 + 1
",error,No,No,No
succ_eq_add_one,succ_eq_add_one_dev_1,-- Rewrite on RHS making n + 0 + succ(0) -> succ(n+0+0),rw [add_succ],rw [add_succ],"n : ℕ
⊢ succ (n + 0) = succ (n + 0 + 0)
",error,Yes,Yes,Yes
succ_eq_add_one,succ_eq_add_one_dev_1,"-- succ(n+0) = succ(n+0), QED",rfl,rfl,,error,Yes,Yes,Yes
succ_eq_add_one,succ_eq_add_one_dev_2,-- Rewrite RHS 1 -> succ(0),rw [one_eq_succ_zero],rw [one_eq_succ_zero],"n : ℕ
⊢ succ n = n + succ 0
","n : ℕ
⊢ succ n = n + succ 0
",Yes,No,Yes
succ_eq_add_one,succ_eq_add_one_dev_2,-- Rewrite both RHS and LHS n -> n + 0,rw [add_zero],rw [← add_zero n],"n : ℕ
⊢ succ (n + 0) = n + 0 + succ 0
",error,No,No,No
succ_eq_add_one,succ_eq_add_one_dev_2,-- Rewrite RHS n + 0 + succ(0) -> succ(n + 0 + 0),rw [add_succ],rw [add_succ],"n : ℕ
⊢ succ (n + 0) = succ (n + 0 + 0)
",error,Yes,No,No
succ_eq_add_one,succ_eq_add_one_dev_2,"-- succ(n) = succ(n), QED",rfl,rfl,,error,Yes,Yes,Yes
add_right_eq_zero,add_right_eq_zero_dev_1,"-- We have two cases: b = 0, or b = succ d for some natural number d.",cases b with d,cases b with d,"case zero
a : ℕ
⊢ a + 0 = 0 → a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case zero
a : ℕ
⊢ a + 0 = 0 → a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_1,"-- In the former case, we must show that a + 0 = 0 → a = 0, so we start by assuming that a + 0 = 0.",intro h,intro h,"case zero
a : ℕ
h : a + 0 = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case zero
a : ℕ
h : a + 0 = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_1,-- We apply the theorem that n + 0 = n change a + 0 = 0 into a = 0.,rw [add_zero] at h,rw [add_zero] at h,"case zero
a : ℕ
h : a = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case zero
a : ℕ
h : a = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_1,"-- So, a = 0, which concludes this case of the theorem.",exact h,exact h,"case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_1,"-- In the latter case, we must show that a + succ d = 0 → a = 0, so we start by assuming that a + succ d = 0.",intro h,intro h,"case succ
a d : ℕ
h : a + succ d = 0
⊢ a = 0
","case succ
a d : ℕ
h : a + succ d = 0
⊢ a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_1,"-- By the symmetry of equality, we have that 0 = succ (a + d).",symm at h,symm at h,"case succ
a d : ℕ
h : 0 = succ (a + d)
⊢ a = 0
","case succ
a d : ℕ
h : 0 = a + succ d
⊢ a = 0
",Yes,Yes,No
exact_2,exact_2_dev_1,-- We simplify the hypothesis of 0 + x = 0 + y + 2 to x = 0 + x + 2.,rw [zero_add] at h,rw [zero_add] at h,"y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
","y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
",Yes,No,Yes
exact_2,exact_2_dev_2,-- 0 + x = 0 + y + 2 -> x = 0 + y + 2,rw [zero_add] at h,rw [zero_add] at h,"y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
","y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
",Yes,No,Yes
zero_mul,zero_mul_dev_1,-- Proof by induction on m with base case 0 * 0 = 0 and inductive step 0 * d + 1 = 0,induction m with d hd,induction m with d hd,"case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
","case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",Yes,No,Yes
zero_mul,zero_mul_dev_1,-- First prove base case. Simplify LHS 0 * 0 to 0,rw [mul_zero],rw [mul_zero],"case zero
⊢ 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
","case zero
⊢ 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",Yes,No,Yes
zero_mul,zero_mul_dev_1,-- Simplify the LHS 0 * d + 0 to 0 + 0 using the definition of addition,rw [add_zero],rw [add_zero],"case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * d = 0
",error,Yes,Yes,Yes
zero_mul,zero_mul_dev_1,-- This is exactly the inductive hypothesis so we can complete the proof.,rfl,exact hd,,error,No,Yes,Yes
zero_mul,zero_mul_dev_2,-- Proof by induction on m with base case 0 * 0 = 0 and inductive step 0 * d + 1 = 0,induction m with d hd,induction m with d hd,"case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
","case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",Yes,No,Yes
zero_mul,zero_mul_dev_2,-- That proves the base case.,rfl,rfl,"case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",error,Yes,Yes,Yes
zero_mul,zero_mul_dev_2,-- This is exactly the inductive hypothesis so we can complete the proof.,rfl,exact hd,,error,No,Yes,Yes
mul_left_ne_zero,mul_left_ne_zero__dev_1,-- Assume that b equals 0.,intro hd,intro hb,"a b : ℕ
h : a * b ≠ 0
hb : b = 0
⊢ False
","a b : ℕ
h : a * b ≠ 0
hd : b = 0
⊢ False
",No,No,Yes
mul_left_ne_zero,mul_left_ne_zero__dev_1,-- We use reflexivity to prove the goal of 0 = 0.,rfl,rfl,,error,Yes,Yes,Yes
mul_left_ne_zero,mul_left_ne_zero__dev_2,-- Assume that b equals 0.,intro hd,intro hd,"a b : ℕ
h : a * b ≠ 0
hd : b = 0
⊢ False
","a b : ℕ
h : a * b ≠ 0
hd : b = 0
⊢ False
",Yes,No,Yes
mul_left_ne_zero,mul_left_ne_zero__dev_2,-- We have 0 != 0 which is a contradiction.,trivial,tauto,,error,No,Yes,Yes
add_left_comm,add_left_comm_dev_1,"-- By associativity of addition, can change a + (b + c) into (a + b) + c",rw [add_assoc],rw [← add_assoc],"a b c : ℕ
⊢ a + b + c = b + (a + c)
",error,No,No,No
add_left_comm,add_left_comm_dev_1,"-- So we just need to show b + (a + c) = b + (a + c), which is true by reflexivity.",rfl,rfl,,error,Yes,Yes,Yes
add_left_comm,add_left_comm_dev_2,-- a + (b + c) = b + (a + c) -> (a + b) + c = b + (a + c),rw [add_assoc],rw [← add_assoc],"a b c : ℕ
⊢ a + b + c = b + (a + c)
",error,No,No,No
add_left_comm,add_left_comm_dev_2,-- lhs = rhs,rw [add_assoc],rfl,,error,No,Yes,Yes
le_two,le_two_dev_1,-- Either x = 0 or x = succ y for some natural number y.,cases x with y,cases x with y,"case zero
hx : 0 ≤ 2
⊢ 0 = 0 ∨ 0 = 1 ∨ 0 = 2
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero
hx : 0 ≤ 2
⊢ 0 = 0 ∨ 0 = 1 ∨ 0 = 2
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- In the former case, we need to show 0 = 0 ∨ 0 = 1 ∨ 0 = 2, and we choose to show 0 = 0.",left,left,"case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_1,-- This is clear by reflexivity.,rfl,rfl,"case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- In the latter case, either y = 0 or y = succ z for some natural number z.",cases y with z,cases y with z,"case succ.zero
hx : succ 0 ≤ 2
⊢ succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case succ.zero
hx : succ 0 ≤ 2
⊢ succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- In the former case, we must show succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2, and we choose to prove succ 0 = 1 ∨ succ 0 = _dev_2",right,right,"case succ.zero.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case succ.zero.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- To prove succ 0 = 1 ∨ succ 0 = 2, we choose to prove succ 0 = _dev_1",left,left,"case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- Rewriting using a theorem, need to show show succ 0 = succ 0.",rfl,rw [one_eq_succ_zero],"case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = succ 0
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",error,No,No,No
le_two,le_two_dev_1,-- This is clear by reflexivity.,rfl,rfl,"case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",error,Yes,No,No
le_two,le_two_dev_1,"-- In the latter case, we substitute 2 = succ 1 and 1 = succ 0 into what we know and what we have to show.","rw [two_eq_succ_one, one_eq_succ_zero] at hx ⊢","rw [two_eq_succ_one, one_eq_succ_zero] at hx ⊢","case succ.succ
z : ℕ
hx : succ (succ z) ≤ succ (succ 0)
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
",error,Yes,No,No
le_two,le_two_dev_1,"-- We know that succ (succ z) ≤ succ (succ 0), so usinig a theorem we know succ z ≤ succ 0.",apply succ_le_succ at hx,apply succ_le_succ at hx,"case succ.succ
z : ℕ
hx : succ z ≤ succ 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
",error,Yes,No,No
le_two,le_two_dev_1,"-- We know that succ z ≤ succ 0, so using a theorem we know that z ≤ 0.",apply succ_le_succ at hx,apply succ_le_succ at hx,"case succ.succ
z : ℕ
hx : z ≤ 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
",error,Yes,No,No
le_two,le_two_dev_1,"-- Since z ≤ 0, using a theorem, z = 0.",apply le_zero at hx,apply le_zero at hx,"case succ.succ
z : ℕ
hx : z = 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
",error,Yes,No,No
le_two,le_two_dev_1,"-- So, we need to show that succ (succ 0) = 0 ∨ succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0), so we choose to show that succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0)",right,right,"case succ.succ.h
z : ℕ
hx : z = 0
⊢ succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0)
",error,Yes,No,No
le_two,le_two_dev_1,"-- But LHS = RHS, so this follows by reflexivity.",rfl,rfl,,error,Yes,Yes,Yes
exact_2,exact_2_dev_1,-- We simplify the hypothesis of 0 + x = 0 + y + 2 to x = 0 + x + 2.,rw [zero_add] at h,rw [zero_add] at h,"y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
","y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
",Yes,No,Yes
exact_2,exact_2_dev_2,-- 0 + x = 0 + y + 2 -> x = 0 + y + 2,rw [zero_add] at h,rw [zero_add] at h,"y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
","y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
",Yes,No,Yes
zero_mul,zero_mul_dev_1,-- Proof by induction on m with base case 0 * 0 = 0 and inductive step 0 * d + 1 = 0,induction m with d hd,induction m with d hd,"case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
","case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",Yes,No,Yes
zero_mul,zero_mul_dev_1,-- First prove base case. Simplify LHS 0 * 0 to 0,rw [mul_zero],rw [mul_zero],"case zero
⊢ 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
","case zero
⊢ 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",Yes,No,Yes
zero_mul,zero_mul_dev_1,-- Simplify the LHS 0 * d + 0 to 0 + 0 using the definition of addition,rw [add_zero],rw [add_zero],"case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * d = 0
",error,Yes,Yes,Yes
zero_mul,zero_mul_dev_1,-- This is exactly the inductive hypothesis so we can complete the proof.,rfl,exact hd,,error,No,Yes,Yes
zero_mul,zero_mul_dev_2,-- Proof by induction on m with base case 0 * 0 = 0 and inductive step 0 * d + 1 = 0,induction m with d hd,induction m with d hd,"case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
","case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",Yes,No,Yes
zero_mul,zero_mul_dev_2,-- That proves the base case.,rfl,rfl,"case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",error,Yes,Yes,Yes
zero_mul,zero_mul_dev_2,-- This is exactly the inductive hypothesis so we can complete the proof.,rfl,exact hd,,error,No,Yes,Yes
mul_left_ne_zero,mul_left_ne_zero__dev_1,-- Assume that b equals 0.,intro hd,intro hb,"a b : ℕ
h : a * b ≠ 0
hb : b = 0
⊢ False
","a b : ℕ
h : a * b ≠ 0
hd : b = 0
⊢ False
",No,No,Yes
mul_left_ne_zero,mul_left_ne_zero__dev_1,-- We use reflexivity to prove the goal of 0 = 0.,rfl,rfl,,error,Yes,Yes,Yes
mul_left_ne_zero,mul_left_ne_zero__dev_2,-- Assume that b equals 0.,intro hd,intro hd,"a b : ℕ
h : a * b ≠ 0
hd : b = 0
⊢ False
","a b : ℕ
h : a * b ≠ 0
hd : b = 0
⊢ False
",Yes,No,Yes
mul_left_ne_zero,mul_left_ne_zero__dev_2,-- We have 0 != 0 which is a contradiction.,trivial,tauto,,error,No,Yes,Yes
add_left_comm,add_left_comm_dev_1,"-- By associativity of addition, can change a + (b + c) into (a + b) + c",rw [add_assoc],rw [← add_assoc],"a b c : ℕ
⊢ a + b + c = b + (a + c)
",error,No,No,No
add_left_comm,add_left_comm_dev_1,"-- So we just need to show b + (a + c) = b + (a + c), which is true by reflexivity.",rfl,rfl,,error,Yes,Yes,Yes
add_left_comm,add_left_comm_dev_2,-- a + (b + c) = b + (a + c) -> (a + b) + c = b + (a + c),rw [add_assoc],rw [← add_assoc],"a b c : ℕ
⊢ a + b + c = b + (a + c)
",error,No,No,No
add_left_comm,add_left_comm_dev_2,-- lhs = rhs,rw [add_assoc],rfl,,error,No,Yes,Yes
le_two,le_two_dev_1,-- Either x = 0 or x = succ y for some natural number y.,cases x with y,cases x with y,"case zero
hx : 0 ≤ 2
⊢ 0 = 0 ∨ 0 = 1 ∨ 0 = 2
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero
hx : 0 ≤ 2
⊢ 0 = 0 ∨ 0 = 1 ∨ 0 = 2
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- In the former case, we need to show 0 = 0 ∨ 0 = 1 ∨ 0 = 2, and we choose to show 0 = 0.",left,left,"case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_1,-- This is clear by reflexivity.,rfl,rfl,"case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- In the latter case, either y = 0 or y = succ z for some natural number z.",cases y with z,cases y with z,"case succ.zero
hx : succ 0 ≤ 2
⊢ succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case succ.zero
hx : succ 0 ≤ 2
⊢ succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- In the former case, we must show succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2, and we choose to prove succ 0 = 1 ∨ succ 0 = _dev_2",right,right,"case succ.zero.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case succ.zero.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- To prove succ 0 = 1 ∨ succ 0 = 2, we choose to prove succ 0 = _dev_1",left,left,"case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",Yes,No,Yes
le_two,le_two_dev_1,"-- Rewriting using a theorem, need to show show succ 0 = succ 0.",rfl,rw [one_eq_succ_zero],"case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = succ 0
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",error,No,No,No
le_two,le_two_dev_1,-- This is clear by reflexivity.,rfl,rfl,"case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",error,Yes,No,No
le_two,le_two_dev_1,"-- In the latter case, we substitute 2 = succ 1 and 1 = succ 0 into what we know and what we have to show.","rw [two_eq_succ_one, one_eq_succ_zero] at hx ⊢","rw [two_eq_succ_one, one_eq_succ_zero] at hx ⊢","case succ.succ
z : ℕ
hx : succ (succ z) ≤ succ (succ 0)
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
",error,Yes,No,No
le_two,le_two_dev_1,"-- We know that succ (succ z) ≤ succ (succ 0), so usinig a theorem we know succ z ≤ succ 0.",apply succ_le_succ at hx,apply succ_le_succ at hx,"case succ.succ
z : ℕ
hx : succ z ≤ succ 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
",error,Yes,No,No
le_two,le_two_dev_1,"-- We know that succ z ≤ succ 0, so using a theorem we know that z ≤ 0.",apply succ_le_succ at hx,apply succ_le_succ at hx,"case succ.succ
z : ℕ
hx : z ≤ 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
",error,Yes,No,No
le_two,le_two_dev_1,"-- Since z ≤ 0, using a theorem, z = 0.",apply le_zero at hx,apply le_zero at hx,"case succ.succ
z : ℕ
hx : z = 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
",error,Yes,No,No
le_two,le_two_dev_1,"-- So, we need to show that succ (succ 0) = 0 ∨ succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0), so we choose to show that succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0)",right,right,"case succ.succ.h
z : ℕ
hx : z = 0
⊢ succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0)
",error,Yes,No,No
le_two,le_two_dev_1,"-- But LHS = RHS, so this follows by reflexivity.",rfl,rfl,,error,Yes,Yes,Yes
le_two,le_two_dev_2,-- x = 0 (case 1) or x = succ y (case 2) for some natural number y,cases x with y,cases x with y,"case zero
hx : 0 ≤ 2
⊢ 0 = 0 ∨ 0 = 1 ∨ 0 = 2
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero
hx : 0 ≤ 2
⊢ 0 = 0 ∨ 0 = 1 ∨ 0 = 2
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_2,-- 0 = 0 ∨ 0 = 1 ∨ 0 = 2 -> 0 = 0,"left
rfl",left,"case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,No,Yes
le_two,le_two_dev_2,-- lhs = rhs,rw [← hx],rfl,"case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,No,Yes
le_two,le_two_dev_2,-- y = 0 (case 1) or y = succ z (case 2) for some natural number z,cases y with z,cases y with z,"case succ.zero
hx : succ 0 ≤ 2
⊢ succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_2,-- succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2 -> succ 0 = 1 ∨ succ 0 = _dev_2,right,right,"case succ.zero.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_2,-- succ 0 = 1 ∨ succ 0 = 2 -> succ 0 = _dev_1,left,left,"case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_2,-- succ 0 = 1 -> succ 0 = succ 0,rfl,rw [one_eq_succ_zero],"case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = succ 0
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,No,Yes
le_two,le_two_dev_2,-- lhs = rhs,rw [← hx],rfl,"case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,No,Yes
le_two,le_two_dev_2,-- succ (succ z) ≤ 2 -> succ (succ z) ≤ succ 1 -> succ (succ z) ≤ succ (succ 0); ... = 0 ∨ ... = 1 ∨ ... = 2 -> ... = 0 ∨ ... = 1 ∨ ... = succ 1 -> ... = 0 ∨ ... = succ 0 ∨ ... = succ (succ 0),"rw [le_succ_self, le_two]","rw [two_eq_succ_one, one_eq_succ_zero] at hx ⊢","case succ.succ
z : ℕ
hx : succ (succ z) ≤ succ (succ 0)
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,No,Yes
le_two,le_two_dev_2,-- succ (succ z) ≤ succ (succ 0) -> succ z ≤ succ 0,apply succ_le_succ at hx,apply succ_le_succ at hx,"case succ.succ
z : ℕ
hx : succ z ≤ succ 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_2,-- succ z ≤ succ 0 -> z ≤ 0,apply succ_le_succ,apply succ_le_succ at hx,"case succ.succ
z : ℕ
hx : z ≤ 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,No,Yes
le_two,le_two_dev_2,-- z ≤ 0 -> z = 0,apply le_zero,apply le_zero at hx,"case succ.succ
z : ℕ
hx : z = 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,No,Yes
le_two,le_two_dev_2,-- succ (succ 0) = 0 ∨ succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0) -> succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0),right,right,"case succ.succ.h
z : ℕ
hx : z = 0
⊢ succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes,No,Yes
le_two,le_two_dev_2,-- lhs = rhs,rw [← hx],rfl,,"case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No,Yes,No
zero_pow_succ,zero_pow_succ_dev_2,"-- We can use induction on m. For the base case, we want to show that 0^succ(0) = 0.",induction m with d hd,induction m with h hd,"case zero
⊢ 0 ^ succ 0 = 0
case succ
h : ℕ
hd : 0 ^ succ h = 0
⊢ 0 ^ succ (succ h) = 0
","case zero
⊢ 0 ^ succ 0 = 0
case succ
d : ℕ
hd : 0 ^ succ d = 0
⊢ 0 ^ succ (succ d) = 0
",No,No,Yes
succ_eq_add_one,succ_eq_add_one_dev_1,-- Rewrite on both RHS and LHS making n -> n + 0,rw [add_zero],rw [← add_zero n],"n : ℕ
⊢ succ (n + 0) = n + 0 + 1
",error,No,No,No
succ_eq_add_one,succ_eq_add_one_dev_1,-- Rewrite on RHS making n + 0 + succ(0) -> succ(n+0+0),rw [add_succ],rw [add_succ],"n : ℕ
⊢ succ (n + 0) = succ (n + 0 + 0)
",error,Yes,Yes,Yes
succ_eq_add_one,succ_eq_add_one_dev_1,"-- succ(n+0) = succ(n+0), QED",rfl,rfl,,error,Yes,Yes,Yes
succ_eq_add_one,succ_eq_add_one_dev_2,-- Rewrite RHS 1 -> succ(0),rw [one_eq_succ_zero],rw [one_eq_succ_zero],"n : ℕ
⊢ succ n = n + succ 0
","n : ℕ
⊢ succ n = n + succ 0
",Yes,No,Yes
succ_eq_add_one,succ_eq_add_one_dev_2,-- Rewrite both RHS and LHS n -> n + 0,rw [add_zero],rw [← add_zero n],"n : ℕ
⊢ succ (n + 0) = n + 0 + succ 0
",error,No,No,No
succ_eq_add_one,succ_eq_add_one_dev_2,-- Rewrite RHS n + 0 + succ(0) -> succ(n + 0 + 0),rw [add_succ],rw [add_succ],"n : ℕ
⊢ succ (n + 0) = succ (n + 0 + 0)
",error,Yes,No,No
succ_eq_add_one,succ_eq_add_one_dev_2,"-- succ(n) = succ(n), QED",rfl,rfl,,error,Yes,Yes,Yes
add_right_eq_zero,add_right_eq_zero_dev_1,"-- We have two cases: b = 0, or b = succ d for some natural number d.",cases b with d,cases b with d,"case zero
a : ℕ
⊢ a + 0 = 0 → a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case zero
a : ℕ
⊢ a + 0 = 0 → a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_1,"-- In the former case, we must show that a + 0 = 0 → a = 0, so we start by assuming that a + 0 = 0.",intro h,intro h,"case zero
a : ℕ
h : a + 0 = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case zero
a : ℕ
h : a + 0 = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_1,-- We apply the theorem that n + 0 = n change a + 0 = 0 into a = 0.,rw [add_zero] at h,rw [add_zero] at h,"case zero
a : ℕ
h : a = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case zero
a : ℕ
h : a = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_1,"-- So, a = 0, which concludes this case of the theorem.",exact h,exact h,"case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_1,"-- In the latter case, we must show that a + succ d = 0 → a = 0, so we start by assuming that a + succ d = 0.",intro h,intro h,"case succ
a d : ℕ
h : a + succ d = 0
⊢ a = 0
","case succ
a d : ℕ
h : a + succ d = 0
⊢ a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_1,"-- By the symmetry of equality, we have that 0 = succ (a + d).",symm at h,symm at h,"case succ
a d : ℕ
h : 0 = succ (a + d)
⊢ a = 0
","case succ
a d : ℕ
h : 0 = a + succ d
⊢ a = 0
",Yes,Yes,No
add_right_eq_zero,add_right_eq_zero_dev_1,"-- Since a contradiction/falsehood implies anything, we are done.",exact h,cases h,,error,No,Yes,Yes
add_right_eq_zero,add_right_eq_zero_dev_2,-- either b = 0 or b = succ d for some natural number d,cases b with d,cases b with d,"case zero
a : ℕ
⊢ a + 0 = 0 → a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case zero
a : ℕ
⊢ a + 0 = 0 → a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_2,-- (case 1) assume a + 0 = 0,intro h,intro h,"case zero
a : ℕ
h : a + 0 = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case zero
a : ℕ
h : a + 0 = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_2,-- a + 0 = 0 -> a = 0,exact h,rw [add_zero] at h,"case zero
a : ℕ
h : a = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",error,No,No,No
add_right_eq_zero,add_right_eq_zero_dev_2,"-- a = 0, as desired",exact h,exact h,"case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",error,Yes,No,No
add_right_eq_zero,add_right_eq_zero_dev_2,-- succ (a + d) = 0 -> 0 = succ (a + d),symm at h,symm at h,"case succ
a d : ℕ
h : 0 = succ (a + d)
⊢ a = 0
",error,Yes,Yes,Yes
add_right_eq_zero,add_right_eq_zero_dev_2,-- 0 = succ (a + d) -> False,apply zero_ne_succ,apply zero_ne_succ at h,"case succ
a d : ℕ
h : False
⊢ a = 0
",error,No,Yes,Yes
add_right_eq_zero,add_right_eq_zero_dev_2,-- False -> anything,trivial,cases h,,error,No,Yes,Yes
zero_add,zero_add__dev_1,-- Induct on n,induction n with d hd,induction n with d hd,"case zero
⊢ 0 + 0 = 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
","case zero
⊢ 0 + 0 = 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
",Yes,No,Yes
zero_add,zero_add__dev_1,-- substitute 0 -> 0 + 0 into the RHS giving us 0 + 0 = 0 + 0,rw [add_zero],nth_rewrite 3 [← add_zero 0],"case zero
⊢ 0 + 0 = 0 + 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
","case zero
⊢ 0 = 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
",No,No,Yes
zero_add,zero_add__dev_1,"-- 0 + 0 = 0 + 0, completing base case",rfl,rfl,"case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
","case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
",Yes,No,Yes
zero_add,zero_add__dev_1,"-- succ d = succ d, QED",rfl,rfl,,error,Yes,Yes,Yes
zero_add,zero_add__dev_2,-- Begin by initiating induction on n,induction n with d hd,induction n with d hd,"case zero
⊢ 0 + 0 = 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
","case zero
⊢ 0 + 0 = 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
",Yes,No,Yes
zero_add,zero_add__dev_2,-- Using the properties of addition by 0 we can rewrite 0 + 0 to 0 on the LHS,rw [add_zero],rw [add_zero],"case zero
⊢ 0 = 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
","case zero
⊢ 0 = 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
",Yes,No,Yes
zero_add,zero_add__dev_2,"-- Since both sides are equal, we are done with the base case",rfl,rfl,"case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
","case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
",Yes,No,Yes
zero_add,zero_add__dev_2,"-- Since both sides are equal, we are done with the proof",rfl,rfl,,error,Yes,Yes,Yes
exact_2,exact_2_dev_1,-- We simplify the hypothesis of 0 + x = 0 + y + 2 to x = 0 + x + 2.,rw [zero_add] at h,rw [zero_add] at h,"y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
","y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
",Yes,No,Yes
exact_2,exact_2_dev_2,-- 0 + x = 0 + y + 2 -> x = 0 + y + 2,rw [zero_add] at h,rw [zero_add] at h,"y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
","y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
",Yes,No,Yes
World Name,Theorem Name,Natural Language,Predicted Formalization,True Tactic,True Goal State,Predicted Goal State,Tactics Match,Is Incorrect Tactic,Correctly Identified As Wrong
exact_2,exact_2_dev_1,-- We simplify the hypothesis of 0 + x = 0 + y + 2 to x = 0 + x + 2.,rw [zero_add] at h,rw [zero_add] at h,"y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
","y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
",Yes,No,Yes
exact_2,exact_2_dev_2,-- 0 + x = 0 + y + 2 -> x = 0 + y + 2,rw [zero_add] at h,rw [zero_add] at h,"y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
","y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
",Yes,No,Yes
exact_2,exact_2_dev_1,-- We simplify the hypothesis of 0 + x = 0 + y + 2 to x = 0 + x + 2.,rw [zero_add] at h,rw [zero_add] at h,"y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
","y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
",Yes,No,Yes
exact_2,exact_2_dev_2,-- 0 + x = 0 + y + 2 -> x = 0 + y + 2,rw [zero_add] at h,rw [zero_add] at h,"y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
","y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
",Yes,No,Yes
exact_2,exact_2_dev_1,-- We simplify the hypothesis of 0 + x = 0 + y + 2 to x = 0 + x + 2.,rw [zero_add] at h,rw [zero_add] at h,"y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
","y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
",Yes,No,Yes
exact_2,exact_2_dev_2,-- 0 + x = 0 + y + 2 -> x = 0 + y + 2,rw [zero_add] at h,rw [zero_add] at h,"y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
","y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
",Yes,No,Yes
exact_2,exact_2_dev_1,-- We simplify the hypothesis of 0 + x = 0 + y + 2 to x = 0 + x + 2.,rw [zero_add] at h,rw [zero_add] at h,"y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
","y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
",Yes,No,Yes
exact_2,exact_2_dev_2,-- 0 + x = 0 + y + 2 -> x = 0 + y + 2,rw [zero_add] at h,rw [zero_add] at h,"y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
","y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
",Yes,No,Yes
exact_2,exact_2_dev_1,-- We simplify the hypothesis of 0 + x = 0 + y + 2 to x = 0 + x + 2.,rw [zero_add] at h,rw [zero_add] at h,"y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
","y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
",Yes,No,Yes
exact_2,exact_2_dev_2,-- 0 + x = 0 + y + 2 -> x = 0 + y + 2,rw [zero_add] at h,rw [zero_add] at h,"y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
","y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
",Yes,No,Yes
succ_mul,succ_mul_dev_1,"-- Induct on b, with d = 0 as the base case and the inductive hypothesis succ a * d = a * d + d. There are now two proof goals, prove base case: succ a * 0 = a * 0 + 0, and inductive step: succ a * succ d = a * succ d + succ d.",induction b with d hd,induction b with d hd,"case zero
a : ℕ
⊢ succ a * 0 = a * 0 + 0
case succ
a d : ℕ
hd : succ a * d = a * d + d
⊢ succ a * succ d = a * succ d + succ d
","case zero
a : ℕ
⊢ succ a * 0 = a * 0 + 0
case succ
a d : ℕ
hd : succ a * d = a * d + d
⊢ succ a * succ d = a * succ d + succ d
",Yes,No,Yes
succ_mul,succ_mul_dev_1,-- First we prove base case. Simplify succ a * 0 = a * 0 + 0 to 0 = 0 by definition of multiplication and addition,"rw [mul_zero, add_zero]","rw [add_zero, mul_zero, mul_zero]","case zero
a : ℕ
⊢ 0 = 0
case succ
a d : ℕ
hd : succ a * d = a * d + d
⊢ succ a * succ d = a * succ d + succ d
","case zero
a : ℕ
⊢ 0 = a * 0
case succ
a d : ℕ
hd : succ a * d = a * d + d
⊢ succ a * succ d = a * succ d + succ d
",No,No,Yes
succ_mul,succ_mul_dev_1,-- The base case is complete.,rfl,rfl,"case succ
a d : ℕ
hd : succ a * d = a * d + d
⊢ succ a * succ d = a * succ d + succ d
",error,Yes,No,No
succ_mul,succ_mul_dev_1,-- Now prove inductive step. We rewrite LHS succ a * succ d to succ a * d + succ a,rw [mul_succ],"rw [mul_succ, mul_succ]","case succ
a d : ℕ
hd : succ a * d = a * d + d
⊢ succ a * d + succ a = a * d + a + succ d
",error,No,No,No
succ_mul,succ_mul_dev_1,-- Apply the commutative property of addition in LHS: a * d + a + d to a * d + d + a,rw [add_comm a d],rw [add_right_comm],"case succ
a d : ℕ
hd : succ a * d = a * d + d
⊢ succ (a * d + a + d) = succ (a * d + a + d)
",error,No,Yes,Yes
succ_mul,succ_mul_dev_1,-- The inductive step is complete.,rfl,rfl,,error,Yes,Yes,Yes
succ_mul,succ_mul_dev_2,"-- Proof by induction on b, with succ a * 0 = a * 0 + 0 as the base case and the inductive case as succ a * d + 1 = a * d + 1 + d + 1.",induction b with d hd,induction b with d hd,"case zero
a : ℕ
⊢ succ a * 0 = a * 0 + 0
case succ
a d : ℕ
hd : succ a * d = a * d + d
⊢ succ a * succ d = a * succ d + succ d
","case zero
a : ℕ
⊢ succ a * 0 = a * 0 + 0
case succ
a d : ℕ
hd : succ a * d = a * d + d
⊢ succ a * succ d = a * succ d + succ d
",Yes,No,Yes
succ_mul,succ_mul_dev_2,-- succ a * 0 = a * 0 + 0 -> 0 = a * 0 + 0,rw [mul_zero],rw [mul_zero],"case zero
a : ℕ
⊢ 0 = a * 0 + 0
case succ
a d : ℕ
hd : succ a * d = a * d + d
⊢ succ a * succ d = a * succ d + succ d
","case zero
a : ℕ
⊢ 0 = a * 0 + 0
case succ
a d : ℕ
hd : succ a * d = a * d + d
⊢ succ a * succ d = a * succ d + succ d
",Yes,No,Yes
succ_mul,succ_mul_dev_2,-- 0 = a * 0 + 0 -> 0 = 0 + 0,rw [mul_zero] at hd,rw [mul_zero],"case zero
a : ℕ
⊢ 0 = 0 + 0
case succ
a d : ℕ
hd : succ a * d = a * d + d
⊢ succ a * succ d = a * succ d + succ d
",error,No,No,No
succ_mul,succ_mul_dev_2,-- 0 = 0 + 0 -> 0 = 0,rfl,rw [add_zero],"case zero
a : ℕ
⊢ 0 = 0
case succ
a d : ℕ
hd : succ a * d = a * d + d
⊢ succ a * succ d = a * succ d + succ d
",error,No,No,No
succ_mul,succ_mul_dev_2,-- Base case is complete.,rfl,rfl,"case succ
a d : ℕ
hd : succ a * d = a * d + d
⊢ succ a * succ d = a * succ d + succ d
",error,Yes,No,No
succ_mul,succ_mul_dev_2,-- succ a * succ d = a * succ d + succ d -> succ a * succ d = succ d + a * succ d,rw [add_comm],rw [add_comm],"case succ
a d : ℕ
hd : succ a * d = a * d + d
⊢ succ a * succ d = succ d + a * succ d
",error,Yes,No,No
succ_mul,succ_mul_dev_2,-- succ a * succ d = succ d + a * succ d -> succ a * d + succ a = succ d + a * succ d,rw [hd],rw [mul_succ],"case succ
a d : ℕ
hd : succ a * d = a * d + d
⊢ succ a * d + succ a = succ d + a * succ d
",error,No,No,No
succ_mul,succ_mul_dev_2,-- ucc a * d + succ a = succ d + a * succ d -> succ (succ a * d + a) = succ d + a * succ d,rw [succ_add],rw [add_succ],"case succ
a d : ℕ
hd : succ a * d = a * d + d
⊢ succ (succ a * d + a) = succ d + a * succ d
",error,No,No,No
succ_mul,succ_mul_dev_2,-- succ (succ a * d + a) = succ d + a * succ d -> succ (succ a * d + a) = succ d + (a * d + a),rw [add_succ],rw [mul_succ],"case succ
a d : ℕ
hd : succ a * d = a * d + d
⊢ succ (succ a * d + a) = succ d + (a * d + a)
",error,No,No,No
succ_mul,succ_mul_dev_2,-- succ (succ a * d + a) = succ (d + (a * d + a)) -> succ (a * d + d + a) = succ (d + (a * d + a)),rw [add_comm],rw [hd],"case succ
a d : ℕ
hd : succ a * d = a * d + d
⊢ succ (a * d + d + a) = succ (d + (a * d + a))
",error,No,Yes,Yes
succ_mul,succ_mul_dev_2,-- succ (a * d + d + a) = succ (d + (a * d + a)) -> succ (a * d + d + a) = succ (d + a * d + a),rw [add_right_comm],rw [← add_assoc],"case succ
a d : ℕ
hd : succ a * d = a * d + d
⊢ succ (a * d + d + a) = succ (d + a * d + a)
",error,No,Yes,Yes
succ_mul,succ_mul_dev_2,-- This completes the inductive step.,rfl,rfl,,error,Yes,Yes,Yes
World Name,Theorem Name,Natural Language,Predicted Formalization,True Tactic,True Goal State,Predicted Goal State,Tactics Match,Is Incorrect Tactic,Correctly Identified As Wrong
one_le_of_ne_zero,one_le_of_ne_zero__dev_1,-- a is either 0 or the successor of some natural number d.,cases a with d hd,cases a with d,"case zero
ha : 0 ≠ 0
⊢ 1 ≤ 0
case succ
d : ℕ
ha : succ d ≠ 0
⊢ 1 ≤ succ d
","case zero
ha : 0 ≠ 0
⊢ 1 ≤ 0
case succ
d : ℕ
ha : succ d ≠ 0
⊢ 1 ≤ succ d
",No,No,Yes
one_le_of_ne_zero,one_le_of_ne_zero__dev_1,"-- When a = 0, the theorem doesn't hold because we know a != 0.",contrapose! ha,tauto,"case succ
d : ℕ
ha : succ d ≠ 0
⊢ 1 ≤ succ d
","case zero
ha : ¬1 ≤ 0
⊢ 0 = 0
case succ
d : ℕ
ha : succ d ≠ 0
⊢ 1 ≤ succ d
",No,No,Yes
one_le_of_ne_zero,one_le_of_ne_zero__dev_1,-- 1 <= d + 1 -> 1 + d = d + 1,rw [add_comm],use d,"case h
d : ℕ
ha : succ d ≠ 0
⊢ d + 1 = 1 + d
",error,No,No,No
one_le_of_ne_zero,one_le_of_ne_zero__dev_1,"-- The LHS and RHS are equal, so we can use reflexivity to prove the goal.",rfl,rfl,,error,Yes,Yes,Yes
one_le_of_ne_zero,one_le_of_ne_zero__dev_2,-- We use induction on a.,induction a with d hd,induction a with d _,"case zero
ha : 0 ≠ 0
⊢ 1 ≤ 0
case succ
d : ℕ
n_ih✝ : d ≠ 0 → 1 ≤ d
ha : succ d ≠ 0
⊢ 1 ≤ succ d
","case zero
ha : 0 ≠ 0
⊢ 1 ≤ 0
case succ
d : ℕ
hd : d ≠ 0 → 1 ≤ d
ha : succ d ≠ 0
⊢ 1 ≤ succ d
",No,No,Yes
one_le_of_ne_zero,one_le_of_ne_zero__dev_2,"-- For the base case, a = 0, the theorem doesn't hold because we know a != 0.",contrapose! ha,tauto,"case succ
d : ℕ
n_ih✝ : d ≠ 0 → 1 ≤ d
ha : succ d ≠ 0
⊢ 1 ≤ succ d
","case zero
ha : ¬1 ≤ 0
⊢ 0 = 0
case succ
d : ℕ
hd : d ≠ 0 → 1 ≤ d
ha : succ d ≠ 0
⊢ 1 ≤ succ d
",No,No,Yes
one_le_of_ne_zero,one_le_of_ne_zero__dev_2,-- we know that 1 <= succ d -> 1 <= d + 1,rw [add_comm],rw [succ_eq_add_one],"case succ
d : ℕ
n_ih✝ : d ≠ 0 → 1 ≤ d
ha : succ d ≠ 0
⊢ 1 ≤ d + 1
",error,No,No,No
one_le_of_ne_zero,one_le_of_ne_zero__dev_2,"-- The LHS and RHS are equal, so we can use reflexivity to prove the goal.",rfl,rfl,,error,Yes,Yes,Yes
add_left_comm,add_left_comm_dev_1,"-- By associativity of addition, can change a + (b + c) into (a + b) + c",rw [add_assoc],rw [← add_assoc],"a b c : ℕ
⊢ a + b + c = b + (a + c)
",error,No,No,No
add_left_comm,add_left_comm_dev_1,"-- So we just need to show b + (a + c) = b + (a + c), which is true by reflexivity.",rfl,rfl,,error,Yes,Yes,Yes
add_left_comm,add_left_comm_dev_2,-- a + (b + c) = b + (a + c) -> (a + b) + c = b + (a + c),rw [add_assoc],rw [← add_assoc],"a b c : ℕ
⊢ a + b + c = b + (a + c)
",error,No,No,No
add_left_comm,add_left_comm_dev_2,-- lhs = rhs,rw [add_assoc],rfl,,error,No,Yes,Yes
World Name,Theorem Name,Natural Language,Predicted Formalization,True Tactic,True Goal State,Predicted Goal State,Tactics Match,Is Incorrect Tactic,Correctly Identified As Wrong
le_antisymm,le_antisymm_dev_1,-- We consider the case where x is less than or equal to y so y = x + some natural number a.,cases hxy with a ha,cases hxy with a ha,"case intro
x y : ℕ
hyx : y ≤ x
a : ℕ
ha : y = x + a
⊢ x = y
","case intro
x y : ℕ
hyx : y ≤ x
a : ℕ
ha : y = x + a
⊢ x = y
",Yes,No,Yes
le_antisymm,le_antisymm_dev_1,-- We consider the case where y is less than or equal to x so x = y + some natural number b.,cases hyx with b hb,cases hyx with b hb,"case intro.intro
x y a : ℕ
ha : y = x + a
b : ℕ
hb : x = y + b
⊢ x = y
","case intro.intro
x y a : ℕ
ha : y = x + a
b : ℕ
hb : x = y + b
⊢ x = y
",Yes,No,Yes
le_antisymm,le_antisymm_dev_1,"-- We substitute y in the goal with x + a, changing our goal to prove that x equals x + a.",rw [ha],rw [ha],"case intro.intro
x y a : ℕ
ha : y = x + a
b : ℕ
hb : x = y + b
⊢ x = x + a
","case intro.intro
x y a : ℕ
ha : y = x + a
b : ℕ
hb : x = y + b
⊢ x = x + a
",Yes,No,Yes
le_antisymm,le_antisymm_dev_1,"-- Using the equality y = x + a, we substitute y in the equation x = y + b with x + a. Then, we re-arrange the right side of the equation x = x + a + b to x = x + (a + b) using the property that addition is associative.","rw [ha] at hb, rw [add_assoc] at hb","rw [ha, add_assoc] at hb","case intro.intro
x y a : ℕ
ha : y = x + a
b : ℕ
hb : x = x + (a + b)
⊢ x = x + a
","case intro.intro
x y a : ℕ
ha : y = x + a
b : ℕ
hb : x = x + a + b
⊢ x = x + a
",No,No,Yes
le_antisymm,le_antisymm_dev_1,-- We flip the equation so that it reads 'x + (a + b) = x' instead of 'x = x + (a + b)'.,symm at hb,symm at hb,"case intro.intro
x y a : ℕ
ha : y = x + a
b : ℕ
hb : x + (a + b) = x
⊢ x = x + a
","case intro.intro
x y a : ℕ
ha : y = x + a
b : ℕ
hb : x = x + a + b
⊢ x = x + a
",Yes,No,Yes
le_antisymm,le_antisymm_dev_1,"-- We substitute a in the equation x = x + a with zero, as given shown above, changing our goal to prove that x equals x.",rw [hb],"rw [hb, add_zero]","case intro.intro
x y a : ℕ
ha : y = x + a
b : ℕ
hb : a = 0
⊢ x = x
","case intro.intro
x y a : ℕ
ha : y = x + a
b : ℕ
hb : x = x + a + b
⊢ x = x + a
",No,Yes,No
le_antisymm,le_antisymm_dev_1,"-- The goal is now to prove that x equals x, which is true by reflexivity.",rfl,rfl,,"case intro.intro
x y a : ℕ
ha : y = x + a
b : ℕ
hb : x = x + a + b
⊢ x = x + a
",Yes,Yes,No
le_antisymm,le_antisymm_dev_2,-- y = x + a,rw [ha],cases hxy with a ha,"case intro
x y : ℕ
hyx : y ≤ x
a : ℕ
ha : y = x + a
⊢ x = y
",error,No,No,No
le_antisymm,le_antisymm_dev_2,-- x = y + b,rw [hb],cases hyx with b hb,"case intro.intro
x y a : ℕ
ha : y = x + a
b : ℕ
hb : x = y + b
⊢ x = y
",error,No,No,No
le_antisymm,le_antisymm_dev_2,-- x = y -> x = x + a,rw [ha],rw [ha],"case intro.intro
x y a : ℕ
ha : y = x + a
b : ℕ
hb : x = y + b
⊢ x = x + a
",error,Yes,No,No
le_antisymm,le_antisymm_dev_2,-- x = y + b -> x = (x + a) + b,rw [ha] at hb,rw [ha] at hb,"case intro.intro
x y a : ℕ
ha : y = x + a
b : ℕ
hb : x = x + a + b
⊢ x = x + a
",error,Yes,No,No
le_antisymm,le_antisymm_dev_2,-- x = (x + a) + a -> x = x + (a + b),rw [add_assoc] at hb,rw [add_assoc] at hb,"case intro.intro
x y a : ℕ
ha : y = x + a
b : ℕ
hb : x = x + (a + b)
⊢ x = x + a
",error,Yes,No,No
le_antisymm,le_antisymm_dev_2,-- x = x + (a + b) -> x + (a + b) = x,symm at hb,symm at hb,"case intro.intro
x y a : ℕ
ha : y = x + a
b : ℕ
hb : x + (a + b) = x
⊢ x = x + a
",error,Yes,No,No
le_antisymm,le_antisymm_dev_2,-- x + (a + b) = x -> a + b = 0,apply add_right_eq_self at hb,apply add_right_eq_self at hb,"case intro.intro
x y a : ℕ
ha : y = x + a
b : ℕ
hb : a + b = 0
⊢ x = x + a
",error,Yes,No,No
le_antisymm,le_antisymm_dev_2,-- a + b = 0 -> a = 0,apply add_left_eq_zero,apply add_right_eq_zero at hb,"case intro.intro
x y a : ℕ
ha : y = x + a
b : ℕ
hb : a = 0
⊢ x = x + a
",error,No,No,No
le_antisymm,le_antisymm_dev_2,-- lhs = rhs,rw [ha],rfl,,error,No,Yes,Yes
World Name,Theorem Name,Natural Language,Predicted Formalization,True Tactic,True Goal State,Predicted Goal State,Tactics Match,Is Incorrect Tactic,Correctly Identified As Wrong
pow_one,pow_one_dev_1,-- a^succ(0) = a,"rw [pow_succ, pow_zero, one_mul]",rw [one_eq_succ_zero],"a : ℕ
⊢ a ^ succ 0 = a
",error,No,No,No
pow_one,pow_one_dev_1,"-- lhs = rhs, so we are done.",rfl,rfl,,error,Yes,Yes,Yes
pow_one,pow_one_dev_2,"-- Using the fact that we defined 1 to be the successor of zero, we can write this as: a^succ(0) = a.",rw [one_eq_succ_zero],rw[one_eq_succ_zero],"a : ℕ
⊢ a ^ succ 0 = a
","a : ℕ
⊢ a ^ succ 0 = a
",No,No,Yes
pow_one,pow_one_dev_2,"-- We defined the power function with the axiom such that for any natural numbers a,b, a^succ(b) = a^b * a. Using this, we can write our goal as: a^0 * a = a",rw [pow_succ],rw[pow_succ],"a : ℕ
⊢ a ^ 0 * a = a
","a : ℕ
⊢ a ^ 0 * a = a
",No,No,Yes
pow_one,pow_one_dev_2,"-- Once again, we can use the fact that 1 is the successor 0, to write: succ(0) * a = a",rw [one_mul],rw[one_eq_succ_zero],"a : ℕ
⊢ succ 0 * a = a
",error,No,Yes,Yes
pow_one,pow_one_dev_2,"-- Since adding zero to any natural number does not change its, we can simplify our goal to: a=a.",rw [add_zero],rw[zero_add],"a : ℕ
⊢ a = a
",error,No,Yes,Yes
pow_one,pow_one_dev_2,"-- Since the LHS and RHS are prcisely the same expression, we are done by reflexivity.",rfl,rfl,,error,Yes,Yes,Yes
World Name,Theorem Name,Natural Language,Predicted Formalization,True Tactic,True Goal State,Predicted Goal State,Tactics Match,Is Incorrect Tactic,Correctly Identified As Wrong
twoaddtwo,twoaddtwo_dev_1,-- 4 -> succ(3) on the RHS to obtain 2 + 2 = succ(3),rw [four_eq_succ_three],rw [four_eq_succ_three],"⊢ 2 + 2 = succ 3
","⊢ 2 + 2 = succ 3
",Yes,No,Yes
twoaddtwo,twoaddtwo_dev_1,-- 3 -> succ(2) on the RHS to obtain 2 + 2 = succ(succ(2)),rw [three_eq_succ_two],rw [three_eq_succ_two],"⊢ 2 + 2 = succ (succ 2)
","⊢ 2 + 2 = succ (succ 2)
",Yes,No,Yes
twoaddtwo,twoaddtwo_dev_1,-- 2 -> succ(1) on the LHS and RHS to obtain succ(1) + succ(1) = succ(succ(succ(1))),nth_rewrite 2 [two_eq_succ_one],rw [two_eq_succ_one],"⊢ succ 1 + succ 1 = succ (succ (succ 1))
","⊢ 2 + succ 1 = succ (succ 2)
",No,No,Yes
twoaddtwo,twoaddtwo_dev_1,--  succ(1) + succ(1) -> succ(succ(1) + 1) on the LHS to obtain succ(succ(1) + 1) = succ(succ(succ(1))),rw [add_succ],rw [add_succ],"⊢ succ (succ 1 + 1) = succ (succ (succ 1))
","⊢ succ (2 + 1) = succ (succ 2)
",Yes,No,Yes
twoaddtwo,twoaddtwo_dev_1,-- succ(succ(succ((0))) + 0 -> succ(succ(succ((0))) on LHS to obtain succ(succ(succ(0))) = succ(succ(succ(0))),rw [add_zero],rw [add_zero],"⊢ succ (succ (succ (succ 0))) = succ (succ (succ (succ 0)))
",error,Yes,Yes,Yes
twoaddtwo,twoaddtwo_dev_1,"-- succ(succ(succ(0))) = succ(succ(succ(0))), QED",rfl,rfl,,error,Yes,Yes,Yes
twoaddtwo,twoaddtwo_dev_2,"-- Use properties of succession, replacing LHS with 2 + succ(1)",rw [add_succ],nth_rewrite 2 [two_eq_succ_one],"⊢ 2 + succ 1 = 4
",error,No,No,No
twoaddtwo,twoaddtwo_dev_2,-- use another property of succession to rewrite LHS to succ(2 + 1),rw [add_succ],rw [add_succ],"⊢ succ (2 + 1) = 4
",error,Yes,No,No
twoaddtwo,twoaddtwo_dev_2,"-- Using properties of succession, rewrite 1 to succ(0) on LHS",rw [one_eq_succ_zero],rw [one_eq_succ_zero],"⊢ succ (2 + succ 0) = 4
",error,Yes,No,No
twoaddtwo,twoaddtwo_dev_2,"-- Using properties of addition by zero, rewrite LHS to succ(succ(2))",rw [add_zero],rw [add_zero],"⊢ succ (succ 2) = 4
",error,Yes,Yes,Yes
twoaddtwo,twoaddtwo_dev_2,"-- Using properties of succession, rewrite to succ(3) on LHS",rw [succ_add],rw [← three_eq_succ_two],"⊢ succ 3 = succ 3
",error,No,Yes,Yes
twoaddtwo,twoaddtwo_dev_2,"-- Prove LHS and RHS are equal, succ(3) = succ(3), completing the proof",rfl,rfl,,error,Yes,Yes,Yes
add_right_eq_zero,add_right_eq_zero_dev_1,"-- We have two cases: b = 0, or b = succ d for some natural number d.",cases b with d,cases b with d,"case zero
a : ℕ
⊢ a + 0 = 0 → a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case zero
a : ℕ
⊢ a + 0 = 0 → a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_1,"-- In the former case, we must show that a + 0 = 0 → a = 0, so we start by assuming that a + 0 = 0.",intro h,intro h,"case zero
a : ℕ
h : a + 0 = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case zero
a : ℕ
h : a + 0 = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_1,-- We apply the theorem that n + 0 = n change a + 0 = 0 into a = 0.,rw [add_zero] at h,rw [add_zero] at h,"case zero
a : ℕ
h : a = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case zero
a : ℕ
h : a = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_1,"-- So, a = 0, which concludes this case of the theorem.",exact h,exact h,"case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_1,"-- In the latter case, we must show that a + succ d = 0 → a = 0, so we start by assuming that a + succ d = 0.",intro h,intro h,"case succ
a d : ℕ
h : a + succ d = 0
⊢ a = 0
","case succ
a d : ℕ
h : a + succ d = 0
⊢ a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_1,"-- By the symmetry of equality, we have that 0 = succ (a + d).",symm at h,symm at h,"case succ
a d : ℕ
h : 0 = succ (a + d)
⊢ a = 0
","case succ
a d : ℕ
h : 0 = a + succ d
⊢ a = 0
",Yes,Yes,No
add_right_eq_zero,add_right_eq_zero_dev_1,"-- Since a contradiction/falsehood implies anything, we are done.",exact h,cases h,,error,No,Yes,Yes
add_right_eq_zero,add_right_eq_zero_dev_2,-- either b = 0 or b = succ d for some natural number d,cases b with d,cases b with d,"case zero
a : ℕ
⊢ a + 0 = 0 → a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case zero
a : ℕ
⊢ a + 0 = 0 → a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_2,-- (case 1) assume a + 0 = 0,intro h,intro h,"case zero
a : ℕ
h : a + 0 = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case zero
a : ℕ
h : a + 0 = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes,No,Yes
add_right_eq_zero,add_right_eq_zero_dev_2,-- a + 0 = 0 -> a = 0,exact h,rw [add_zero] at h,"case zero
a : ℕ
h : a = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",error,No,No,No
add_right_eq_zero,add_right_eq_zero_dev_2,"-- a = 0, as desired",exact h,exact h,"case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",error,Yes,No,No
add_right_eq_zero,add_right_eq_zero_dev_2,-- succ (a + d) = 0 -> 0 = succ (a + d),symm at h,symm at h,"case succ
a d : ℕ
h : 0 = succ (a + d)
⊢ a = 0
",error,Yes,Yes,Yes
add_right_eq_zero,add_right_eq_zero_dev_2,-- 0 = succ (a + d) -> False,apply zero_ne_succ,apply zero_ne_succ at h,"case succ
a d : ℕ
h : False
⊢ a = 0
",error,No,Yes,Yes
add_right_eq_zero,add_right_eq_zero_dev_2,-- False -> anything,trivial,cases h,,error,No,Yes,Yes
World Name,Theorem Name,Natural Language,Predicted Formalization,True Tactic,True Goal State,Predicted Goal State,Tactics Match,Is Incorrect Tactic,Correctly Identified As Wrong
succ_add,succ_add__dev_1,-- Initiate induction on b,induction b with d hd,induction b with n hn,"case zero
a : ℕ
⊢ succ a + 0 = succ (a + 0)
case succ
a n : ℕ
hn : succ a + n = succ (a + n)
⊢ succ a + succ n = succ (a + succ n)
","case zero
a : ℕ
⊢ succ a + 0 = succ (a + 0)
case succ
a d : ℕ
hd : succ a + d = succ (a + d)
⊢ succ a + succ d = succ (a + succ d)
",No,No,Yes
succ_add,succ_add__dev_1,-- succ(a) + 0 -> succ(a) on LHS giving us succ(a) = succ(a+0),rw [add_zero],rw [add_zero],"case zero
a : ℕ
⊢ succ a = succ (a + 0)
case succ
a n : ℕ
hn : succ a + n = succ (a + n)
⊢ succ a + succ n = succ (a + succ n)
","case zero
a : ℕ
⊢ succ a = succ (a + 0)
case succ
a d : ℕ
hd : succ a + d = succ (a + d)
⊢ succ a + succ d = succ (a + succ d)
",Yes,No,Yes
succ_add,succ_add__dev_1,-- a + 0 -> a on RHS giving us succ(a) = succ(a),rw [add_zero],rw [add_zero],"case zero
a : ℕ
⊢ succ a = succ a
case succ
a n : ℕ
hn : succ a + n = succ (a + n)
⊢ succ a + succ n = succ (a + succ n)
","case zero
a : ℕ
⊢ succ a = succ a
case succ
a d : ℕ
hd : succ a + d = succ (a + d)
⊢ succ a + succ d = succ (a + succ d)
",Yes,No,Yes
succ_add,succ_add__dev_1,"-- succ(a) = succ(a), Hence we are done with the base case",rfl,rfl,"case succ
a n : ℕ
hn : succ a + n = succ (a + n)
⊢ succ a + succ n = succ (a + succ n)
","case succ
a d : ℕ
hd : succ a + d = succ (a + d)
⊢ succ a + succ d = succ (a + succ d)
",Yes,No,Yes
succ_add,succ_add__dev_1,-- Now for the induction case. succ(a) + succ(n) -> succ(succ(a) + n) on LHS giving us succ(succ(a) + n) = succ(a + succ(n)),rw [add_succ],rw [add_succ],"case succ
a n : ℕ
hn : succ a + n = succ (a + n)
⊢ succ (succ a + n) = succ (a + succ n)
","case succ
a d : ℕ
hd : succ a + d = succ (a + d)
⊢ succ (succ a + d) = succ (a + succ d)
",Yes,No,Yes
succ_add,succ_add__dev_1,"-- succ(succ(a) + n) = succ(succ(a) + n), QED",rfl,rfl,,error,Yes,Yes,Yes
succ_add,succ_add__dev_2,-- Initiate induction on b.,induction b with d hd,induction b with n hn,"case zero
a : ℕ
⊢ succ a + 0 = succ (a + 0)
case succ
a n : ℕ
hn : succ a + n = succ (a + n)
⊢ succ a + succ n = succ (a + succ n)
","case zero
a : ℕ
⊢ succ a + 0 = succ (a + 0)
case succ
a d : ℕ
hd : succ a + d = succ (a + d)
⊢ succ a + succ d = succ (a + succ d)
",No,No,Yes
succ_add,succ_add__dev_2,"-- We start by proving the base case using properties of succession, succ(a+0) = a + succ(0) on RHS",rw [add_succ],rw [← add_succ],"case zero
a : ℕ
⊢ succ a + 0 = a + succ 0
case succ
a n : ℕ
hn : succ a + n = succ (a + n)
⊢ succ a + succ n = succ (a + succ n)
",error,No,No,No
succ_add,succ_add__dev_2,"-- Now using properties of addition by 0, we can rewrite succ(a) + 0 to succ(a) on the LHS",rw [add_zero],rw [add_zero],"case zero
a : ℕ
⊢ succ a = a + succ 0
case succ
a n : ℕ
hn : succ a + n = succ (a + n)
⊢ succ a + succ n = succ (a + succ n)
",error,Yes,No,No
succ_add,succ_add__dev_2,"-- Now using properties of succession, we can rewrite succ(a) + 0 to succ(a+0) on the RHS",rw [add_zero],rw [add_succ],"case zero
a : ℕ
⊢ succ a = succ (a + 0)
case succ
a n : ℕ
hn : succ a + n = succ (a + n)
⊢ succ a + succ n = succ (a + succ n)
",error,No,No,No
succ_add,succ_add__dev_2,"-- Now using properties of addition by 0, we can rewrite a + 0 to a on the RHS",rw [add_zero],rw [add_zero],"case zero
a : ℕ
⊢ succ a = succ a
case succ
a n : ℕ
hn : succ a + n = succ (a + n)
⊢ succ a + succ n = succ (a + succ n)
",error,Yes,No,No
succ_add,succ_add__dev_2,"-- since succ(a) = succ(a), we are done with the base case",rfl,rfl,"case succ
a n : ℕ
hn : succ a + n = succ (a + n)
⊢ succ a + succ n = succ (a + succ n)
",error,Yes,No,No
succ_add,succ_add__dev_2,"-- Now again using properties of succession, we substitute succ(a + succ(n)) to succ(succ(a + n)) on the RHS",rw [add_succ],rw [add_succ],"case succ
a n : ℕ
hn : succ a + n = succ (a + n)
⊢ succ (succ a + n) = succ (succ (a + n))
",error,Yes,Yes,Yes
succ_add,succ_add__dev_2,"-- both sides are equal, hence we are done",rfl,rfl,,error,Yes,Yes,Yes
