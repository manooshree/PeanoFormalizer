theorem,NL,FL,filename
zero_add,Prove that 0 + n = n for all natural numbers,theorem zero_add (n : ℕ) : 0 + n = n := by,AdditionClean.lean
succ_add,Prove that succ (a) + b  = succ (a + b) for all natural numbers,theorem succ_add (a b : ℕ) : succ a + b = succ (a + b)  := by,AdditionClean.lean
succ_add_2,Prove that succ (a) + b  = succ (a + b) for all natural numbers,theorem succ_add_2 (a b : ℕ) : succ a + b = succ (a + b)  := by,AdditionClean.lean
add_comm,"Prove that addition is commutative, that is a + b  = b + a for all natural numbers",theorem add_comm (a b : ℕ) : a + b = b + a := by,AdditionClean.lean
add_comm_2,"Prove that addition is commutative, that is a + b  = b + a for all natural numbers",theorem add_comm_2 (a b : ℕ) : a + b = b + a := by,AdditionClean.lean
add_comm_3,"Prove that addition is commutative, that is a + b  = b + a for all natural numbers",theorem add_comm_3 (a b : ℕ) : a + b = b + a := by,AdditionClean.lean
add_right_comm,"Prove that the addition of natural numbers is commutative, that is a + b + c = a + c + b",theorem add_right_comm (a b c : ℕ) : a + b + c = a + c + b := by,AdditionClean.lean
add_right_comm,"Apply the associative property of addition to rewrite the LHS of the equation, changing a + b + c to a + (b + c)",rw [add_assoc],AdditionClean.lean
add_right_comm,"Rewrite the LHS of the equation by applying the commutative property of addition to b and c, LHS is now a + (c + b)",rw [add_comm b],AdditionClean.lean
add_right_comm,Rewrite the RHS using the associative property: a + c + b to a + (c + b).,rw [add_assoc],AdditionClean.lean
add_right_comm,"Prove LHS and RHS are equal, a + (c + b) = a + (c + b), completing the proof",rfl,AdditionClean.lean
add_right_comm_2,"Prove that the addition of natural numbers is commutative, that is a + b + c = a + c + b",theorem add_right_comm_2 (a b c : ℕ) : a + b + c = a + c + b := by,AdditionClean.lean
add_right_comm_2,Apply the associative property of addition to rewrite the LHS: a + b + c to a + (b + c).,rw [add_assoc],AdditionClean.lean
add_right_comm_2,Rewrite the LHS using the commutative property of addition for b and c: a + (b + c) to a + (c + b).,rw [add_comm b c],AdditionClean.lean
add_right_comm_2,Rewrite the RHS using the associative property of addition: a + c + b to a + (c + b).,rw [add_assoc],AdditionClean.lean
add_right_comm_2,"Prove LHS and RHS are equal, completing the proof.",rfl,AdditionClean.lean
add_right_cancel,Prove that a + n = b + n implies a = b for all natural numbers,theorem add_right_cancel (a b n : ℕ) : a + n = b + n → a = b := by,AdvAdditionClean.lean
add_right_cancel,"Induct on n, with d = 0 as the base case and the inductive hypothesis a + d = b + d. There are now two proof goals, prove base case: a + 0 = b + 0 and inductive step: a + succ (d) = b + succ (d) implies a = b.",induction n with d hd,AdvAdditionClean.lean
add_right_cancel,"Assume that the hypothesis 'h' is true, that is, a + 0 = b + 0. The goal now is to prove that a = b.",intro h,AdvAdditionClean.lean
add_right_cancel,"Repeatedly apply the rewrite rule add_zero to the hypothesis h, which simplifies any terms of the form x + 0 in h to x. In this case",repeat rw [add_zero] at h,AdvAdditionClean.lean
add_right_cancel,"Apply the hypothesis 'h' to the goal, changing it to: if 'a + succ d' equals 'b + succ d', then 'a' equals 'b'",exact h,AdvAdditionClean.lean
add_right_cancel,Introduce a hypothesis h: a + succ d = b + succ d. Now the goal is to prove a = b given this hypothesis.,intro h,AdvAdditionClean.lean
add_right_cancel,"For any natural numbers x and y, x + succ y = succ (x + y). Applying this repeatedly simplifies the hypothesis but leaves the goal state a = b unchanged.",repeat rw [add_succ] at h,AdvAdditionClean.lean
add_right_cancel,"If succ a = succ b, then a = b which simplifies the hypotheses.",apply succ_inj at h,AdvAdditionClean.lean
add_right_cancel,Apply the inductive hypothesis 'hd' at the hypothesis 'h'. This simplifies the hypothesis to a = b.,apply hd at h,AdvAdditionClean.lean
add_right_cancel,h proves the goal a = b so we can use it to finish the proof,exact h,AdvAdditionClean.lean
add_left_cancel,Prove that a + n = b + n implies a = b for all natural numbers,theorem add_left_cancel (a b n : ℕ) : n + a = n + b → a = b := by,AdvAdditionClean.lean
add_left_cancel,"Rewrite the goal by repeatedly swapping the addition operands in the left side of both equations, changing n + a = n + b to a + n = b + n.",repeat rw [add_comm n],AdvAdditionClean.lean
add_left_cancel,"Assume that the statement 'a + n = b + n' is true and denote it as 'h'. Then, our new goal is to prove that 'a = b'.",intro h,AdvAdditionClean.lean
add_left_cancel,"Simplify the hypothesis 'h' using the theorem 'add_right_cancel' assuming the theorem is true, which leaves the goal state unchanged as 'a = b'",apply add_right_cancel at h,AdvAdditionClean.lean
add_left_cancel,h proves the goal a = b so we can use it to finish the proof,exact h,AdvAdditionClean.lean
five,Prove that 2 + 2 does not equal 5,theorem five : (2 : ℕ) + 2 ≠ 5 := by,Algorithm2Clean.lean
succ_peano,"Prove that for natural numbers a, b, a = b, given that succ a = succ b",theorem succ_peano (a b : ℕ) (h : succ a = succ b) : a = b := by,AlgorithmClean.lean
succ_ne_zero,"Prove the Peano axiom that the successor of a natural number cannot be 0 for all natural numbers ""a"".",theorem succ_ne_zero (a : ℕ) : succ a ≠ 0 := by,AlgorithmClean.lean
succ_ne_zero,Introduce the statement that succ a = 0 is false,intro h,AlgorithmClean.lean
succ_ne_zero,Rewrite the proof goal to succ a = 0 if succ (a) is 0,rw [← is_zero_succ a],AlgorithmClean.lean
succ_ne_zero,Rewrite the proof goal to showing that succ a = 0 if 0 is zero,rw [h],AlgorithmClean.lean
succ_ne_zero,Simplify the if 0 is zero condition to true,rw [is_zero_zero],AlgorithmClean.lean
succ_ne_zero,"We prove that our initial statement, of succ a = 0 is false, is indeed a true statement, completing the proof",trivial,AlgorithmClean.lean
succ_ne_succ,"Prove the Peano axiom that two numbers of which the successors are equal are themselves equal for natural numbers m, n",theorem succ_ne_succ (m n : ℕ) (h : m ≠ n) : succ m ≠ succ n := by,AlgorithmClean.lean
succ_ne_succ,"Introduce the contrapositive, proving that m = n, given that succ m = succ n",contrapose! h,AlgorithmClean.lean
succ_ne_succ,"Simplify succ m = succ n to m = n, using the injectivity of the successor",apply succ_inj at h,AlgorithmClean.lean
succ_ne_succ,"We can exactly prove that m = n, with our given fact, to complete the proof",exact h,AlgorithmClean.lean
exact,"Prove that given some x, y, z which are natural numbers, x + y = 37. We can assume that x + y = 37 and 3 * x + z = 42",theorem exact (x y z : ℕ) (h1 : x + y = 37) (h2 : 3 * x + z = 42) : x + y = 37 := by,ImplicationClean.lean
exact_2,"For some x which is a natural number, given that  0 + x = 0 + y + 2, prove x = y + 2",theorem exact_2 (x : ℕ) (h : 0 + x = 0 + y + 2) : x = y + 2 := by,ImplicationClean.lean
exact_2,Rewrite 0 + x in the LHS of the hypothesis to x,rw [zero_add] at h,ImplicationClean.lean
exact_2,Rewrite 0 + y to y in the RHS of the hypothesis,rw [zero_add] at h,ImplicationClean.lean
exact_2,"Our simplified hypothesis is now x = y + 2, we can use this exactly to complete the proof",exact h,ImplicationClean.lean
exact_3,"For some x which is a natural number, given that  0 + x = 0 + y + 2, prove x = y + 2",theorem exact_3 (x : ℕ) (h : 0 + x = 0 + y + 2) : x = y + 2 := by,ImplicationClean.lean
exact_3,"Rewrite 0 + x in the LHS of our given,  0 + x = 0 + y + 2, to x and 0 + y to y in the RHS of the hypothesis",repeat rw [zero_add] at h,ImplicationClean.lean
exact_3,"Our simplified hypothesis is now x = y + 2, we can use this exactly to complete the proof",exact h,ImplicationClean.lean
exact_5,"For some x which is a natural number, given x + 1 = 4, prove that x = 3",theorem exact_5 (x : ℕ) (h : x + 1 = 4) : x = 3 := by,ImplicationClean.lean
exact_5,"Rewrite 4 as succ 3 in the given x + 1 = 4, changing it to x + 1 = succ 3",rw [four_eq_succ_three] at h,ImplicationClean.lean
exact_5,Rewrite LHS such that x + 1 = succ 3 changes to succ x = succ 3,rw [←succ_eq_add_one] at h,ImplicationClean.lean
exact_5,"Apply the injectivity of the successor function to the given succ x = succ 3, simplifying to x = 3.",apply succ_inj at h,ImplicationClean.lean
exact_5,"We can exactly prove that x = 3 with our given facts, to complete the proof",exact h,ImplicationClean.lean
exact_7,"For some x which is a natural number, prove that x = 37 implies x = 37",theorem exact_7 (x : ℕ) : x = 37 → x = 37 := by,ImplicationClean.lean
exact_7,We assume that x = 37,intro h,ImplicationClean.lean
exact_7,"We can use this to prove x = 37, completing the proof",exact h,ImplicationClean.lean
exact_8,"For some x and which are natural numbers, prove that x + 1 = y + 1 implies x = y",theorem exact_8 (x : ℕ) : x + 1 = y + 1 → x = y := by,ImplicationClean.lean
exact_8,We assume that x + 1 = y + 1,intro h,ImplicationClean.lean
exact_8,Rewrite x + 1 and y + 1 to succ x and succ y in the LHS and RHS respectively,repeat rw [← succ_eq_add_one] at h,ImplicationClean.lean
exact_8,"Apply the injectivity of the successor function to 'succ x = succ y', simplifying it to 'x = y'.",apply succ_inj at h,ImplicationClean.lean
exact_8,"We can exactly show that x + 1 = y + 1 implies x = y, completing the proof",exact h,ImplicationClean.lean
exact_9,"For some x and which are natural numbers, prove that x + 1 = y + 1 implies x = y",theorem exact_9 (x : ℕ) : x + 1 = y + 1 → x = y := by,ImplicationClean.lean
exact_9,We assume that x + 1 = y + 1,intro h,ImplicationClean.lean
exact_9,Rewrite the proof goal to 'succ x = succ y' using the injectivity of the successor function,apply succ_inj,ImplicationClean.lean
exact_9,"Rewrite all instances of succ x and succ y as x + 1 and y + 1, the equation is now x + 1 = y + 1",repeat rw [succ_eq_add_one],ImplicationClean.lean
exact_9,"We can exactly show how x = y equates to x + 1 = y + 1, completing the proof",exact h,ImplicationClean.lean
exact_10,"For some x and which are natural numbers, prove that both x = y and x ≠ y cannot be true",theorem exact_10 (x y : ℕ) (h1 : x = y) (h2 : x ≠ y) : False := by,ImplicationClean.lean
exact_10,"We apply the assumption that x ≠ y to the hypothesis that x = y, which contradicts it and results in a falsehood",apply h2 at h1,ImplicationClean.lean
exact_10,"We have proven that both x = y and x ≠ y cannot be true, completing the proof",exact h1,ImplicationClean.lean
zero_ne_one,"Given that 0 is a natural number, prove that 0 ≠ 1",theorem zero_ne_one : (0 : ℕ) ≠ 1 := by,ImplicationClean.lean
zero_ne_one,"Assume that 0 = 1, which is false",intro h,ImplicationClean.lean
zero_ne_one,"Apply the Peano axiom that zero is not the successor of any natural number to our assumption that 0 = 1, making it false",apply zero_ne_succ at h,ImplicationClean.lean
zero_ne_one,"We have proven that 0 = 1 is false or that 0 ≠ 1, completing the proof",exact h,ImplicationClean.lean
one_ne_zero,"Given that 1 is a natural number, prove that 1 ≠ 0",theorem one_ne_zero : (1 : ℕ) ≠ 0 := by,ImplicationClean.lean
one_ne_zero,Rewrite our proof goal to 0 ≠ 1,symm,ImplicationClean.lean
one_ne_zero,"Apply the proof that 0 ≠ 1 exactly to our proof goal, completing the proof",exact zero_ne_one,ImplicationClean.lean
two_five,Prove that 2 + 2 ≠ 5;  written in successor terms: succ (succ 0) + succ (succ 0) ≠ succ (succ (succ (succ (succ 0)))),theorem two_five : succ (succ 0) + succ (succ 0) ≠ succ (succ (succ (succ (succ 0)))) := by,ImplicationClean.lean
two_five,Assume that succ (succ 0) + succ (succ 0) = succ (succ (succ (succ (succ 0)))),intro h,ImplicationClean.lean
two_five,"Rewrite the RHS of our assumption, transforming succ (succ 0) + succ (succ 0) to succ (succ (succ (succ 0)))","rw [add_succ, add_succ, add_zero] at h",ImplicationClean.lean
two_five,Repeatedly apply the injectivity of the successor function to the assumption until we simplify the assumption equation to 0 = succ 0,repeat apply succ_inj at h,ImplicationClean.lean
two_five,"Apply the fact that zero is not equal to the successor of zero, showing our assumption is false",apply zero_ne_succ at h,ImplicationClean.lean
two_five,"We have shown that succ (succ 0) + succ (succ 0) ≠ succ (succ (succ (succ (succ 0)))) is false, completing the proof",exact h,ImplicationClean.lean
le_refl,Prove that x ≤ x for any natural number x,theorem le_refl (x : ℕ) : x ≤ x := by,LessOrEqualClean.lean
le_refl,We claim that x is equal to x plus zero.,use 0,LessOrEqualClean.lean
le_refl,"The goal is to prove that x equals x plus zero. By applying the theorem that states that adding zero to any natural number results in the original number, the goal simplifies to proving that x equals x.",rw [add_zero],LessOrEqualClean.lean
le_refl,"The goal is now to prove that x equals x, which is true by reflexivity.",rfl,LessOrEqualClean.lean
zero_le,Prove that 0 ≤ x for any natural number x,theorem zero_le (x : ℕ) : 0 ≤ x := by,LessOrEqualClean.lean
zero_le,Assume that the natural number x is the case we are considering. We need to show that x is equal to 0 plus x.,use x,LessOrEqualClean.lean
zero_le,"Rewrite the goal replacing 0 + x with x, based on the fact that adding zero to any natural number results in the same natural number.",rw [zero_add],LessOrEqualClean.lean
zero_le,"The goal is now to prove that x equals x, which is true by reflexivity.",rfl,LessOrEqualClean.lean
le_trans,"Prove that if x ≤ y and y ≤ z, then x ≤ z for any natural numbers x, y, and z",theorem le_trans (x y z : ℕ) (hxy : x ≤ y) (hyz : y ≤ z) : x ≤ z := by,LessOrEqualClean.lean
le_trans,Break down the assumption that x is less than or equal to y into a specific case where there exists a natural number 'a' such that y equals x plus 'a'.,cases hxy with a ha,LessOrEqualClean.lean
le_trans,Break down the assumption that y is less than or equal to z into a specific case where there exists a natural number 'b' such that z equals y plus 'b'.,cases hyz with b hb,LessOrEqualClean.lean
le_trans,Use the case of a + b to simplify the goal to equal z = x + (a + b).,use a + b,LessOrEqualClean.lean
le_trans,"Substitute z with y + b and y with x + a in the goal, resulting in the equation x + a + b = x + (a + b).","rw [hb, ha]",LessOrEqualClean.lean
le_trans,"The goal is now to prove that x + a + b = x + (a + b), which can be proven by applying the theorem that states that addition is associative to the left-hand side of the goal.",exact add_assoc x a b,LessOrEqualClean.lean
le_trans1,"Prove that if x ≤ y and y ≤ z, then x ≤ z for any natural numbers x, y, and z",theorem le_trans1 (x y z : ℕ) (hxy : x ≤ y) (hyz : y ≤ z) : x ≤ z := by,LessOrEqualClean.lean
le_trans1,Break down the assumption that x is less than or equal to y into a specific case where there exists a natural number 'a' such that y equals x plus 'a'.,cases hxy with a ha,LessOrEqualClean.lean
le_trans1,Break down the assumption that y is less than or equal to z into a specific case where there exists a natural number 'b' such that z equals y plus 'b'.,cases hyz with b hb,LessOrEqualClean.lean
le_trans1,Use the case of a + b to simplify the goal to equal z = x + (a + b).,use a + b,LessOrEqualClean.lean
le_trans1,Substitute z with y + b resulting in the equation y + b = x + (a + b).,rw [hb],LessOrEqualClean.lean
le_trans1,Substitute y with x + a resulting in the equation x + a + b = x + (a + b).,rw [ha],LessOrEqualClean.lean
le_trans1,"The goal is now to prove that x + a + b = x + (a + b), which can be proven by applying the theorem that states that addition is associative to the left-hand side of the goal.",exact add_assoc x a b,LessOrEqualClean.lean
le_zero,"Prove that if x ≤ 0, then x = 0 for any natural number x",theorem le_zero (x : ℕ) (hx : x ≤ 0) : x = 0 := by,LessOrEqualClean.lean
le_zero,The goal is to prove that x equals 0 given that x is less than or equal to 0. We then consider the case where x is the sum of 0 and some natural number y. This gives us the equation 0 = x + y. Our goal now is to show that x equals 0 given this equation.,cases hx with y hy,LessOrEqualClean.lean
le_zero,Flip the equation so that it reads 'x + y = 0' instead of '0 = x + y'.,symm at hy,LessOrEqualClean.lean
le_zero,"The sum of x and y is zero implies that y is zero because for all natural numbers a and n, n + a = 0 implies a = 0.",apply add_right_eq_zero at hy,LessOrEqualClean.lean
le_zero,"The goal is now to prove that x = 0, which can be proven by applying hy to the goal.",exact hy,LessOrEqualClean.lean
le_antisymm,"Prove that if x is less than or equal to y and y is less than or equal to x, then x equals y.",theorem le_antisymm (x y : ℕ) (hxy : x ≤ y) (hyx : y ≤ x) : x = y := by,LessOrEqualClean.lean
le_antisymm,We consider the case where x is less than or equal to y so y = x + some natural number a.,cases hxy with a ha,LessOrEqualClean.lean
le_antisymm,We consider the case where y is less than or equal to x so x = y + some natural number b.,cases hyx with b hb,LessOrEqualClean.lean
le_antisymm,"We substitute y in the goal with x + a, changing our goal to prove that x equals x + a.",rw [ha],LessOrEqualClean.lean
le_antisymm,"Using the equality y = x + a, we substitute y in the equation x = y + b with x + a.",rw [ha] at hb,LessOrEqualClean.lean
le_antisymm,We re-arrange the right side of the equation x = x + a + b to x = x + (a + b) using the property that addition is associative.,rw [add_assoc] at hb,LessOrEqualClean.lean
le_antisymm,We flip the equation so that it reads 'x + (a + b) = x' instead of 'x = x + (a + b)'.,symm at hb,LessOrEqualClean.lean
le_antisymm,"If x + (a + b) = x, then a + b = 0 by since for all natural numbers a and n, n + a = n implies a = 0.",apply add_right_eq_self at hb,LessOrEqualClean.lean
le_antisymm,"If a + b = 0, then a = 0 and b = 0 by since for all natural numbers a and n, n + a = 0 implies a = 0.",apply add_right_eq_zero at hb,LessOrEqualClean.lean
le_antisymm,We substitute a with zero in the goal.,rw [hb],LessOrEqualClean.lean
le_antisymm,We simplify x + 0 to x.,rw [add_zero],LessOrEqualClean.lean
le_antisymm,"The goal is now to prove that x equals x, which is true by reflexivity.",rfl,LessOrEqualClean.lean
orr_symm,"Prove that if x equals 37 or y equals 42, then y equals 42 or x equals 37.",theorem orr_symm (x y : ℕ) (h : x = 37 ∨ y = 42) : y = 42 ∨ x = 37 := by,LessOrEqualClean.lean
orr_symm,"We consider the two possible cases given that either x equals 37 or y equals 42. For both cases, we aim to show that y equals 42 or x equals 37.",cases h with hx hy,LessOrEqualClean.lean
orr_symm,"We choose to prove the right side of the disjunction, which is x = 37.",right,LessOrEqualClean.lean
orr_symm,"We are given that x equals 37, so we can use this to prove the goal.",exact hx,LessOrEqualClean.lean
orr_symm,"We choose to prove the left side of the disjunction, which is y = 42.",left,LessOrEqualClean.lean
orr_symm,"We are given that y equals 42, so we can use this to prove the goal.",exact hy,LessOrEqualClean.lean
le_total,"Prove that for any natural numbers x and y, either x is less than or equal to y or y is less than or equal to x.",theorem le_total (x y : ℕ) : x ≤ y ∨ y ≤ x := by,LessOrEqualClean.lean
le_total,"Induct on y, with d = 0 as the base case and the inductive hypothesis x = d. There are now two proof goals, prove base case: x <= 0 or 0 <= x and inductive step: x <= d + 1 or d + 1 <= x.",induction y with d hd,LessOrEqualClean.lean
le_total,"We choose to prove the right side of the disjunction, which is 0 ≤ x.",right,LessOrEqualClean.lean
le_total,"We assert that 0 is less than or equal to any natural number x, which completes the proof for this case.",exact zero_le x,LessOrEqualClean.lean
le_total,"We consider the two cases: either 'x' is less than or equal to 'd', or 'd' is less than or equal to 'x'. For both cases, we aim to show that x is less than or equal to d + 1 or d + 1 is less than or equal to x.",cases hd with h1 h2,LessOrEqualClean.lean
le_total,"We choose to prove the left side of the disjunction, which is x ≤ d + 1.",left,LessOrEqualClean.lean
le_total,We consider the case that x is less than or equal to d. We know this is true because there exists a natural number e such that d equals x plus e.,cases h1 with e h1,LessOrEqualClean.lean
le_total,"We substitute d with x + e in the goal, resulting in the equation x = x + e + 1.",rw [h1],LessOrEqualClean.lean
le_total,Use the case of e + 1 to simplify the goal to succ (x + e) = x + (e + 1).,use e + 1,LessOrEqualClean.lean
le_total,"We first rewrite the left-hand side expression 'succ (x + e)' to 'x + e + 1' using the theorem that states the successor of a number is equal to the number plus one. Then, we use the theorem that addition is associative to rearrange 'x + e + 1' to 'x + (e + 1)'.","rw [succ_eq_add_one, add_assoc]",LessOrEqualClean.lean
le_total,"The goal is now to prove that x + (e + 1) = x + (e + 1), which is true by reflexivity.",rfl,LessOrEqualClean.lean
le_total,"We consider the case where d is less than or equal to x. We then break down this case into two subcases: one where x is equal to d plus some natural number e, and the other where x is greater than d by some natural number e.",cases h2 with e he,LessOrEqualClean.lean
le_total,We consider the cases that e is zero or the successor of a natural number a.,cases e with a,LessOrEqualClean.lean
le_total,"We substitute x with d + 0 in the goal, resulting in the the goal d + 0 ≤ succ d ∨ succ d ≤ d + 0.",rw [he],LessOrEqualClean.lean
le_total,"We choose to prove the left side of the disjunction, which is d + 0 ≤ succ d.",left,LessOrEqualClean.lean
le_total,We rewrite the left-hand side of the goal to d because d + 0 = d.,rw [add_zero],LessOrEqualClean.lean
le_total,We use the case of 1 to simplify the goal to succ d = d + 1.,use 1,LessOrEqualClean.lean
le_total,"The goal is to prove that succ d equals d + 1. We directly apply the fact that the successor of a natural number d is equal to d + 1, which completes the proof for this goal.",exact succ_eq_add_one d,LessOrEqualClean.lean
le_total,"We choose to prove the right side of the disjunction, which is succ d <= x.",right,LessOrEqualClean.lean
le_total,We use the case of a to rewrite the goal to succ x = succ d + a.,use a,LessOrEqualClean.lean
le_total,The goal is to prove that succ d equals d + 1. We directly apply the fact that the successor of a natural number d is equal to d + 1.,rw [add_succ] at he,LessOrEqualClean.lean
le_total,Rewrite the right hand side of the goal using the theorem that adding a successor to a natural number is the same as adding the natural number and then taking the successor. This leaves the goal unchanged in this case.,rw [succ_add],LessOrEqualClean.lean
le_total,"We have shows that x = succ d + a, so we can use this to prove the goal.",exact he,LessOrEqualClean.lean
succ_le_succ,"Prove that if the successor of x is less than or equal to the successor of y, then x is less than or equal to y.",theorem succ_le_succ (x y : ℕ) (hx : succ x ≤ succ y) : x ≤ y := by,LessOrEqualClean.lean
succ_le_succ,We consider the case where the successor of x is less than or equal to the successor of y. This implies that the successor of y is equal to the successor of x plus some natural number d.,cases hx with d hd,LessOrEqualClean.lean
succ_le_succ,We assume d as the difference such that when added to x results in y. The goal now is to prove that y is equal to x plus d.,use d,LessOrEqualClean.lean
succ_le_succ,We rewrite the right-hand side of succ y = succ x + d using the theorem that states the the successor of a sum of two natural numbers is the same as the successor of the first number added to the second number.,rw [succ_add] at hd,LessOrEqualClean.lean
succ_le_succ,"We apply the property that if two natural numbers with successors are equal, then the original numbers are also equal.",apply succ_inj at hd,LessOrEqualClean.lean
succ_le_succ,"We have shown that x = y + d, so we can use this to prove the goal.",exact hd,LessOrEqualClean.lean
le_one,"Prove that if x is less than or equal to 1, then x is equal to 0 or 1.",theorem le_one (x : ℕ) (hx : x ≤ 1) : x = 0 ∨ x = 1 := by,LessOrEqualClean.lean
le_one,"We consider the case where x is a natural number. We then break down this case into two subcases: one where x is equal to 0, and the other where x is equal to the successor of another natural number y.",cases x with y,LessOrEqualClean.lean
le_one,"We choose to prove the left side of the disjunction, which is 0 = 0.",left,LessOrEqualClean.lean
le_one,"We are given that 0 equals 0, so we can use reflexivity to prove the goal.",rfl,LessOrEqualClean.lean
le_one,"Replace 1 with the successor of 0. This means we are given that the succ y <= succ 0, and the updated goal is that the succ y = 0 or the succ y = succ 0.",rw [one_eq_succ_zero] at hx ⊢,LessOrEqualClean.lean
le_one,"We use the property that if one natural number is less than or equal to another, then their successors also maintain this relationship. This means that y <= 0.",apply succ_le_succ at hx,LessOrEqualClean.lean
le_one,"We apply the property that if x is less than or equal to 0, then x must be equal to 0 so y = 0.",apply le_zero at hx,LessOrEqualClean.lean
le_one,"We substitute y with 0 in the goal, resulting in the goal succ 0 = 0 ∨ succ 0 = succ 0.",rw [hx],LessOrEqualClean.lean
le_one,"We choose to prove the right side of the disjunction, which is succ 0 = succ 0.",right,LessOrEqualClean.lean
le_one,"We are given that succ 0 equals succ 0, so we can use reflexivity to prove the goal.",rfl,LessOrEqualClean.lean
le_two,"Prove that if x is less than or equal to 2, then x is equal to 0, 1, or 2.",theorem le_two (x : ℕ) (hx : x ≤ 2) : x = 0 ∨ x = 1 ∨ x = 2 := by,LessOrEqualClean.lean
le_two,"We consider the case where x is a natural number. We then break down this case into two subcases: one where x is equal to 0, and the other where x is equal to the successor of another natural number y.",cases x with y,LessOrEqualClean.lean
le_two,"We choose to prove the left side of the disjunction, which is 0 = 0.",left,LessOrEqualClean.lean
le_two,"We are given that 0 equals 0, so we can use reflexivity to prove the goal.",rfl,LessOrEqualClean.lean
le_two,"We consider the case where y is a natural number. We then break down this case into two subcases: one where y is equal to 0, and the other where y is equal to the successor of another natural number z.",cases y with z,LessOrEqualClean.lean
le_two,"We choose to prove the right side of the disjunction, which is succ 0 = 1 ∨ succ 0 = 2.",right,LessOrEqualClean.lean
le_two,"We choose to prove the left side of the disjunction, which is succ 0 = 1.",left,LessOrEqualClean.lean
le_two,We rewrite the goal using the theorem that states the successor of 0 is equal to 1.,rw [one_eq_succ_zero],LessOrEqualClean.lean
le_two,"We are given that 0 equals 0, so we can use reflexivity to prove the goal.",rfl,LessOrEqualClean.lean
le_two,"We rewrite the number 2 as the successor of 1, and 1 as the successor of 0. Now was know that 'succ (succ z) ≤ succ (succ 0)' and the goal to 'succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)'.","rw [two_eq_succ_one, one_eq_succ_zero] at hx ⊢",LessOrEqualClean.lean
le_two,We simplify succ (succ z) <= succ (succ 0) to the assumption that the succ z <= succ 0.,apply succ_le_succ at hx,LessOrEqualClean.lean
le_two,We simplify succ z <= succ 0 to z <= 0.,apply succ_le_succ at hx,LessOrEqualClean.lean
le_two,"We apply the property that if z is less than or equal to 0, then z must be equal to 0.",apply le_zero at hx,LessOrEqualClean.lean
le_two,"We substitute z with 0 in the goal, resulting in the goal succ (succ 0) = 0 ∨ succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0).",rw [hx],LessOrEqualClean.lean
le_two,"We choose to prove the right side of the disjunction, which is succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0).",right,LessOrEqualClean.lean
le_two,"We choose to prove the right side of this disjunction, which is succ (succ 0) = succ (succ 0).",right,LessOrEqualClean.lean
le_two,"We have that succ (succ 0) = succ (succ 0), so we can use reflexivity to prove the goal.",rfl,LessOrEqualClean.lean
mul_one,"Prove the multiplicative identity property, the multiplication of m * 1 is m, for all natural numbers",theorem mul_one (m : ℕ) : m * 1 = m := by,MultiplicationClean.lean
mul_one,"Rewrite 1 as succ 0, using the axiom that succ 0 = 1",rw [one_eq_succ_zero],MultiplicationClean.lean
mul_one,Rewrite LHS m * succ 0 to m * 0 + m using the definition of multiplication with a successor.,rw [mul_succ],MultiplicationClean.lean
mul_one,Simplify m * 0 + m to 0 + m on LHS,rw [mul_zero],MultiplicationClean.lean
mul_one,Rewrite the LHS 0 + m = m,rw [zero_add],MultiplicationClean.lean
mul_one,"Prove LHS and RHS are equal, m = m, completing the proof",rfl,MultiplicationClean.lean
zero_mul,Prove that 0 * m = m for all natural numbers,theorem zero_mul (m : ℕ) : 0 * m = 0 := by,MultiplicationClean.lean
succ_mul,"Prove that succ a * b = a * b + b for all natural numbers a, b",theorem succ_mul (a b : ℕ) : succ a * b = a * b + b := by,MultiplicationClean.lean
succ_mul,"Induct on b, with d = 0 as the base case and the inductive hypothesis succ a * d = a * d + d. There are now two proof goals, prove base case: succ a * 0 = a * 0 + 0, and inductive step: succ a * succ d = a * succ d + succ d.",induction b with d hd,MultiplicationClean.lean
succ_mul,First we prove base case. Simplify the LHS from succ a * 0 to 0,· rw [mul_zero],MultiplicationClean.lean
succ_mul,Simplify LHS a * 0 = 0,rw [mul_zero],MultiplicationClean.lean
succ_mul,Simplify RHS 0 + 0 to 0,rw [add_zero],MultiplicationClean.lean
succ_mul,"Prove LHS and RHS are equal, 0 = 0, completing base case",rfl,MultiplicationClean.lean
succ_mul,Now prove inductive step. We rewrite LHS succ a * succ d to succ a * d + succ a,· rw [mul_succ],MultiplicationClean.lean
succ_mul,Expand the RHS from a * succ d + succ d to a * d + a + succ d,rw [mul_succ],MultiplicationClean.lean
succ_mul,Rewrite the LHS  succ a * d + succ a to a * d + d + succ a using the inductive hypothesis,rw [hd],MultiplicationClean.lean
succ_mul,Rewrite the LHS  a * d + d + succ a to succ (a * d + d + a),rw [add_succ],MultiplicationClean.lean
succ_mul,"Rewrite RHS, changing a * d + a + succ d to succ (a * d + a + d)",rw [add_succ],MultiplicationClean.lean
succ_mul,Apply  commutative property of additionin LHS: a * d + d + a to a * d + a + d,rw [add_right_comm],MultiplicationClean.lean
succ_mul,"Prove LHS and RHS are equal, succ (a * d + a + d) = succ (a * d + a + d), completing the proof",rfl,MultiplicationClean.lean
mul_comm_2,"Prove that multiplication is commutative, that is a * b = b * a for all natural numbers",theorem mul_comm_2 (a b : ℕ) : a * b = b * a := by,MultiplicationClean.lean
mul_comm_2,"Induct on b, with d = 0 as the base case and the inductive hypothesis a * d = d * a.",induction b with d hd,MultiplicationClean.lean
mul_comm_2,"Prove LHS and RHS are equal, 0 = 0, completing base case.",rfl,MultiplicationClean.lean
mul_comm_2,Use the inductive hypothesis within the context of addition.,rw [hd],MultiplicationClean.lean
mul_comm_2,"Prove LHS and RHS are equal, a * d + a = a * d + a, completing the proof.",rfl,MultiplicationClean.lean
one_mul_2,"Prove that 1 * m = m, for all natural numbers",theorem one_mul_2 (m : ℕ): 1 * m = m := by,MultiplicationClean.lean
one_mul_2,Apply the commutative property of multiplication to rewrite LHS from 1 * m to m * 1 and then simplify to m,"rw [mul_comm, mul_one]",MultiplicationClean.lean
one_mul_2,"Prove LHS and RHS are equal, m = m, completing the proof",rfl,MultiplicationClean.lean
two_mul,Prove that 2 * m = m + m for all natural numbers,theorem two_mul (m : ℕ): 2 * m = m + m := by,MultiplicationClean.lean
two_mul,"Rewrite 2 as succ(1), changing LHS from 2 * m to succ 1 * m",rw [two_eq_succ_one],MultiplicationClean.lean
two_mul,Rewrite the LHS succ 1 * m to 1 * m + m,rw [succ_mul],MultiplicationClean.lean
two_mul,Simplify LHS from 1 * m + m to m + m by identity property of multiplication,rw [one_mul],MultiplicationClean.lean
two_mul,"Prove LHS and RHS are equal, m + m = m + m, completing the proof",rfl,MultiplicationClean.lean
two_mul_2,Prove that 2 * m = m + m for all natural numbers,theorem two_mul_2 (m : ℕ): 2 * m = m + m := by,MultiplicationClean.lean
two_mul_2,Rewrite LHS from 2 * m to succ 1 * m and simplify to m * m using identity property of multiplication,"rw [two_eq_succ_one, succ_mul, one_mul]",MultiplicationClean.lean
two_mul_2,"Prove LHS and RHS are equal, m + m = m + m, completing the proof",rfl,MultiplicationClean.lean
mul_add,"Prove that multiplication is distributive over addition. In other words, for all natural numbers a * (b + c) = a * b + a * c",theorem mul_add (a b c : ℕ) : a * (b + c) = a * b + a * c := by,MultiplicationClean.lean
mul_add,"Induct on b, with b = 0 as the base case and the inductive hypothesis a * b = a * b + a * c. There are now two proof goals, prove base case: a * (0 + c) = a * 0 + a * c, and inductive step: a * (succ b + c) = a * succ b + a * c",induction b with b hb,MultiplicationClean.lean
mul_add,First prove base case. Simplify LHS a * (0 + c) to a * c and RHS a * 0 + a * c to 0 + a * c and then simplify to a * c,"rw [zero_add, mul_zero, zero_add]",MultiplicationClean.lean
mul_add,"Prove LHS and RHS are equal, a * c = a * c, completing the base case",rfl,MultiplicationClean.lean
mul_add,Next prove the inductive step. Rewrite LHS a * (succ b + c) to a * succ (b + c) and then to  a * (b + c) + a,"rw [succ_add, mul_succ]",MultiplicationClean.lean
mul_add,Rewrite RHS from a * succ b + a * c to a * b + a + a * c and then rearrange terms to a * b + a * c + a,"rw [mul_succ, add_right_comm]",MultiplicationClean.lean
mul_add,Rewrite the LHS a * (b + c) + a to a * b + a * c + a using the inductive hypothesis,rw [hb],MultiplicationClean.lean
mul_add,"Prove LHS and RHS are equal, a * b + a * c + a = a * b + a * c + a, completing the proof",rfl,MultiplicationClean.lean
mul_add_2,"Prove that multiplication is distributive over addition. In other words, for all natural numbers a * (b + c) = a * b + a * c",theorem mul_add_2 (a b c : ℕ) : a * (b + c) = a * b + a * c := by,MultiplicationClean.lean
mul_add_2,"Induct on a, with a = 0 as the base case and the inductive hypothesis a * (b + c) = a * b + a * c. There are now two proof goals, prove base case: 0 * (b + c) = 0 * b + 0 * c, and inductive step: succ a * (b + c) = succ a * b + succ a * c",induction a with a ha,MultiplicationClean.lean
mul_add_2,First prove base case. Simplify LHS to 0 and RHS to 0 + 0 and then 0 by applying the rules of multiplication and addition with zero,"rw [zero_mul, zero_mul, zero_mul, zero_add]",MultiplicationClean.lean
mul_add_2,"Prove LHS and RHS are equal, 0 = 0, completing base case",rfl,MultiplicationClean.lean
mul_add_2,Next prove inductive step. Expand LHS from succ a * (b + c) to a * (b + c) + (b + c) . Expand RHS from succ a * b + succ a * c to a * b + b + (a * c + c),"rw [succ_mul, succ_mul, succ_mul]",MultiplicationClean.lean
mul_add_2,Rewrite LHS using the inductive hypothesis from a * (b + c) + (b + c) to a * b + a * c + (b + c),rw [ha],MultiplicationClean.lean
mul_add_2,Apply the associative property of addition everywhere appropriate. Simplify the equation  to: a * b + a * c + (b + c) = a * b + b + (a * c + c),repeat rw [add_assoc],MultiplicationClean.lean
mul_add_2,"Rewrite LHS by applying the associative property of addition to the term a*c, then swapping the terms b and a*c, and finally applying the associative property of addition. This results in the final equation a * b + (b + (a * c + c)) = a * b + (b + (a * c + c))","rw [← add_assoc (a*c), add_comm _ b, add_assoc]",MultiplicationClean.lean
mul_add_2,"-- Prove LHS and RHS are equal, a * b + (b + (a * c + c)) = a * b + (b + (a * c + c)), completing inductive step",rfl,MultiplicationClean.lean
mul_add_3,"Prove that multiplication is distributive over addition. In other words, for all natural numbers a * (b + c) = a * b + a * c",theorem mul_add_3 (a b c : ℕ) : a * (b + c) = a * b + a * c := by,MultiplicationClean.lean
mul_add_3,"Induct on c, with d = 0 as the base case and the inductive hypothesis a * (b + d) = a * b + a * d. There are now two proof goals, prove base case: a * (b + 0) = a * b + a * 0, and inductive step: a * (b + succ d) = a * b + a * succ d.",induction c with d hd,MultiplicationClean.lean
mul_add_3,"First prove the base case. Simplify both sides of the equation by replacing 'b + 0' with 'b', 'a * 0' with '0', and 'a * b + 0' with 'a * b'. Now the LHS and RHS are: a * b = a * b","rw [add_zero, mul_zero, add_zero]",MultiplicationClean.lean
mul_add_3,"Prove LHS and RHS are equal, a * b = a * b, completing base case",rfl,MultiplicationClean.lean
mul_add_3,"Next prove inductive step. Rewrite the LHS from a * (b + succ d) to a * b + a * succ d and then simplify to a * (b + d) + a. Then, rewrite a * succ d to a * d + a using the definition of multiplication with succ. Then, apply the inductive hypothesis hd to rewrite a * succ d to a * d + a. Finally, rewrite a * succ d to a * d + a and use the associative property of addition to rearrange the terms to a * b + (a * d + a).","rw [add_succ, mul_succ]",MultiplicationClean.lean
mul_add_3,"Rewrite LHS a * b + (a * d + a), to a * b + a * d + a using the inductive hypothesis",rw [hd],MultiplicationClean.lean
mul_add_3,Rewrite RHS a * b + a * succ d toa * b + (a * d + a) and rearrange the LHS a * b + a * d + a to a * b + (a * d + a),"rw [mul_succ, add_assoc]",MultiplicationClean.lean
mul_add_3,"Prove LHS and RHS are equal, a * b + (a * d + a) = a * b + (a * d + a), completing base case",rfl,MultiplicationClean.lean
mul_assoc,"Prove that multiplication is associative for all natural numbers, that is (a * b) * c = a * (b * c)",theorem mul_assoc (a b c : ℕ) : (a * b) * c = a * (b * c) := by,MultiplicationClean.lean
mul_assoc,"Induct on c, with d = 0 as the base case and the inductive hypothesis a * b * d = a * (b * d). There are now two proof goals, prove base case: a * b * 0 = a * (b * 0), and inductive step: a * b * succ d = a * (b * succ d).",induction c with d hd,MultiplicationClean.lean
mul_assoc,"First prove base case. Rewrite LHS and RHS using the fact that any natural number multiplied by zero equals zero, simplifying the equation to 0 = 0","· rw [mul_zero, mul_zero, mul_zero]",MultiplicationClean.lean
mul_assoc,"Prove LHS and RHS are equal, 0 = 0, completing base case",rfl,MultiplicationClean.lean
mul_assoc,Next prove inductive step. Rewrite LHS from a * b * succ d to a * b * d + a * b,· rw [mul_succ],MultiplicationClean.lean
mul_assoc,Rewrite RHS from a * (b * succ d) to a * (b * d + b),rw [mul_succ],MultiplicationClean.lean
mul_assoc,Rewrite LHS a * b * d + a * b using the inductive hypothesis to a * (b * d) + a * b,rw [hd],MultiplicationClean.lean
mul_assoc,"Rewrite RHS using the distributive property of multiplication over addition, changing a * (b * d + b) to a * (b * d) + a * b",rw [mul_add],MultiplicationClean.lean
mul_assoc,"Prove LHS and RHS are equal, a * (b * d) + a * b = a * (b * d) + a * b, completing base case",rfl,MultiplicationClean.lean
zero_pow_zero,Prove that 0 to the power of 0 is 1,theorem zero_pow_zero : (0 : ℕ) ^ 0 = 1 := by,PowerClean.lean
zero_pow_zero,Rewrite the left-hand side of the equation using the theorem that any number to the power of 0 is 1,rw [pow_zero],PowerClean.lean
zero_pow_zero,"The goal is now to prove that 1 = 1, which is true by reflexivity",rfl,PowerClean.lean
pow_one,Prove that a^1 = a,theorem pow_one (a : ℕ) : a ^ 1 = a  := by,PowerClean.lean
pow_one,Rewrite the left hand side using the identity that 1 is equal to the successor of 0,rw [one_eq_succ_zero],PowerClean.lean
pow_one,"Rewrite the left hand side using the identity that any natural number raised to the power of the successor of another natural number is equal to that number raised to the power of the other number, multiplied by the original number.",rw [pow_succ],PowerClean.lean
pow_one,Rewrite the left hand side using the identity that any natural number to the power of 0 is 1,rw [pow_zero],PowerClean.lean
pow_one,Rewrite the left hand side using the identity that any natural number multiplied by 1 is equal to that natural number,rw [one_mul],PowerClean.lean
pow_one,"The goal is now to prove that a = a, which is true by reflexivity",rfl,PowerClean.lean
one_pow,Prove that 1^m = 1,theorem one_pow (m : ℕ) : (1 : ℕ) ^ m = 1 := by,PowerClean.lean
one_pow,"Induct on m, with d = 0 as the base case and the inductive hypothesis 1^d = 1. There are now two proof goals, prove base case: 1^0 = 1 and inductive step: 1^d = 1 implies 1^(succ d) = 1.",induction m with d hd,PowerClean.lean
one_pow,Rewrite the left hand side using the identity that any natural number to the power of 0 is 1,rw [pow_zero],PowerClean.lean
one_pow,"The goal is now to prove that 1 = 1, which is true by reflexivity",rfl,PowerClean.lean
one_pow,"Rewrite the left hand side using the identity that any natural number raised to the power of the successor of another natural number is equal to that number raised to the power of the other number, multiplied by the original number.",rw [pow_succ],PowerClean.lean
one_pow,Rewrite the left hand side using the induction hypothesis,rw [hd],PowerClean.lean
one_pow,Rewrite the left hand side using the identity that any natural number multiplied by 1 is equal to that natural number,rw [mul_one],PowerClean.lean
one_pow,"The goal is now to prove that 1 = 1, which is true by reflexivity",rfl,PowerClean.lean
pow_two,Prove that a^2 = a * a,theorem pow_two (a : ℕ) : a ^ 2 = a * a := by,PowerClean.lean
pow_two,Rewrite the left hand side using the identity that 2 is equal to the successor of 1,rw [two_eq_succ_one],PowerClean.lean
pow_two,"Rewrite the left hand side using the identity that any natural number raised to the power of the successor of another natural number is equal to that number raised to the power of the other number, multiplied by the original number.",rw [pow_succ],PowerClean.lean
pow_two,Rewrite the left hand side using the identity that any natural number to the power of 1 is equal to that natural number,rw [pow_one],PowerClean.lean
pow_two,"The goal is now to prove that a * a = a * a, which is true by reflexivity",rfl,PowerClean.lean
pow_add,Prove that a^(m + n) = a^m * a^n,theorem pow_add (a m n : ℕ) : a ^ (m + n) = a ^ m * a ^ n := by,PowerClean.lean
pow_add,"Induct on n, with d = 0 as the base case and the inductive hypothesis a^(m + d) = a^m * a^d. There are now two proof goals, prove base case: a^(m + 0) = a^m * a^0 and inductive step: a^(m + d) = a^m * a^d implies a^(m + succ d) = a^m * a^(succ d).",induction n with d hd,PowerClean.lean
pow_add,Rewrite the left hand side using the identity that the sum of any natural number and 0 is equal to that natural number,rw [add_zero],PowerClean.lean
pow_add,Rewrite the left hand side using the identity that any natural number to the power of 0 is 1,rw [pow_zero],PowerClean.lean
pow_add,Rewrite the left hand side using the identity that any natural number multiplied by 1 is equal to that natural number,rw [mul_one],PowerClean.lean
pow_add,"The goal is now to prove that a^m = a^m, which is true by reflexivity",rfl,PowerClean.lean
pow_add,Rewrite the left hand side using the identity that the sum of any natural number and the successor of another natural number is equal to the successor of the sum of the two natural numbers,rw [add_succ],PowerClean.lean
pow_add,"Rewrite the left hand side using the identity that any natural number raised to the power of the successor of another natural number is equal to that number raised to the power of the other number, multiplied by the original number",rw [pow_succ],PowerClean.lean
pow_add,"Rewrite the left hand side using the identity that any natural number raised to the power of the successor of another natural number is equal to that number raised to the power of the other number, multiplied by the original number",rw [pow_succ],PowerClean.lean
pow_add,Rewrite the left hand side using the induction hypothesis,rw [hd],PowerClean.lean
pow_add,Rewrite the left hand side using the identity that any natural number multiplied by the product of two natural numbers is equal to the product of the first natural number multiplied by the second natural number multiplied by the third natural number,rw [mul_assoc],PowerClean.lean
pow_add,"The goal is now to prove that a^m * (a^d * a) = a^m * a^(d + 1), which is true by reflexivity",rfl,PowerClean.lean
pow_add1,Prove that a^(m + n) = a^m * a^n,theorem pow_add1 (a m n : ℕ) : a ^ (m + n) = a ^ m * a ^ n := by,PowerClean.lean
pow_add1,"Induct on n, with d = 0 as the base case and the inductive hypothesis a^(m + d) = a^m * a^d. There are now two proof goals, prove base case: a^(m + 0) = a^m * a^0 and inductive step: a^(m + d) = a^m * a^d implies a^(m + succ d) = a^m * a^(succ d).",induction n with t ht,PowerClean.lean
pow_add1,"Rewrite the goal by first simplifying the expression m + 0 to m, then simplifying a raised to the power of 0 to 1, and finally simplifying any number multiplied by 1 to the number itself. This results in the goal a^m = a^m.","rw [add_zero, pow_zero, mul_one]",PowerClean.lean
pow_add1,"The goal is now to prove that a^m = a^m, which is true by reflexivity",rfl,PowerClean.lean
pow_add1,"Rewrite the expression a^(m + succ t) as a^m * (a^t * a) using the fact that (m + succ t) is the same as (succ (m + t)), and that a raised to the power (succ (m + t)) is the same as (a^(m + t) * a). Also, use the inductive hypothesis that a^(m + t) is equivalent to a^m * a^t, and the fact that multiplication is associative","rw [add_succ, pow_succ, pow_succ, ht, mul_assoc]",PowerClean.lean
pow_add1,"The goal is now to prove that a^m * (a^d * a) = a^m * a^(d + 1), which is true by reflexivity",rfl,PowerClean.lean
mul_pow,Prove that (a * b)^n = a^n * b^n,theorem mul_pow (a b n : ℕ) : (a * b) ^ n = a ^ n * b ^ n := by,PowerClean.lean
mul_pow,"Induct on n, with d = 0 as the base case and the inductive hypothesis (a * b)^d = a^d * b^d. There are now two proof goals, prove base case: (a * b)^0 = a^0 * b^0 and inductive step: (a * b)^d = a^d * b^d implies (a * b)^(succ d) = a^(succ d) * b^(succ d).",induction n with d hd,PowerClean.lean
mul_pow,Rewrite the left hand side using the identity that any natural number to the power of 0 is 1,rw [pow_zero],PowerClean.lean
mul_pow,Rewrite the left hand side using the identity that any natural number to the power of 0 is 1,rw [pow_zero],PowerClean.lean
mul_pow,Rewrite the left hand side using the identity that any natural number to the power of 0 is 1,rw [pow_zero],PowerClean.lean
mul_pow,Rewrite the left hand side using the identity that any natural number multiplied by 1 is equal to that natural number,rw [mul_one],PowerClean.lean
mul_pow,"The goal is now to prove that 1 = 1, which is true by reflexivity",rfl,PowerClean.lean
mul_pow,"Rewrite the left hand side using the identity that any natural number raised to the power of the successor of another natural number is equal to that number raised to the power of the other number, multiplied by the original number",rw [pow_succ],PowerClean.lean
mul_pow,"Rewrite the left hand side using the identity that any natural number raised to the power of the successor of another natural number is equal to that number raised to the power of the other number, multiplied by the original number",rw [pow_succ],PowerClean.lean
mul_pow,"Rewrite the left hand side using the identity that any natural number raised to the power of the successor of another natural number is equal to that number raised to the power of the other number, multiplied by the original number",rw [pow_succ],PowerClean.lean
mul_pow,Rewrite the left hand side using the induction hypothesis,rw [hd],PowerClean.lean
mul_pow,Rearrange the multiplication in both sides of the equation to group them in a different order using the associative property of multiplication.,repeat rw [mul_assoc],PowerClean.lean
mul_pow,"Rearrange the multiplication in the right-hand side of the equation, changing 'a * (b^d * b)' to 'b^d * b * a'",rw [mul_comm a (_ * b)],PowerClean.lean
mul_pow,"Rewrite the right-hand side of the equation to move the multiplication of b and a inside the parentheses, changing b^d * b * a to b^d * (b * a).",rw [mul_assoc],PowerClean.lean
mul_pow,"We rewrite the expression to swap the order of multiplication in b * a to a * b, since multiplication is commutative for natural numbers.",rw [mul_comm b a],PowerClean.lean
mul_pow,"The goal is now to prove that a^d * (b^d * (a * b)) = a^d * (b^d * (a * b)), which is true by reflexivity",rfl,PowerClean.lean
pow_pow,"Prove that any natural number to the power of the power of another natural number is equal to that natural number to the power of the first natural number, multiplied by that natural number to the power of the second natural number",theorem pow_pow (a m n : ℕ) : (a ^ m) ^ n = a ^ (m * n) := by,PowerClean.lean
pow_pow,"Induct on n, with d = 0 as the base case and the inductive hypothesis (a ^ m) ^ t = a ^ (m * t). There are now two proof goals, prove base case: (a ^ m) ^ 0 = a ^ (m * 0) and inductive step: (a ^ m) ^ t = a ^ (m * t) implies (a ^ m) ^ succ t = a ^ (m * succ t).",induction n with t Ht,PowerClean.lean
pow_pow,Rewrite m * 0 to 0 in the right side,rw [mul_zero],PowerClean.lean
pow_pow,Rewrite (a ^ m) ^ 0 to 1 in the left side,rw [pow_zero],PowerClean.lean
pow_pow,Rewrite a ^ 0 to 1 in the right side,rw [pow_zero],PowerClean.lean
pow_pow,"The goal is now to prove that 1 = 1, which is true by reflexivity",rfl,PowerClean.lean
pow_pow,Rewrite the left-hand side using the theorem that states (x^n)^(succ t) = (x^n)^t * (x^n),rw [pow_succ],PowerClean.lean
pow_pow,Use the induction hypothesis to replace (a^m)^t with a^(m*t),rw [Ht],PowerClean.lean
pow_pow,Rewrite the right-hand side using the theorem that states m*(succ t) = m*t + m,rw [mul_succ],PowerClean.lean
pow_pow,Rewrite the right-hand side using the theorem that states x^(a+b) = x^a * x^b,rw [pow_add],PowerClean.lean
pow_pow,"The goal is now to prove that a^(m\*t) * a^m = a^(m*t) * a^m, which is true by reflexivity",rfl,PowerClean.lean
pow_pow2,"Prove that any natural number to the power of the power of another natural number is equal to that natural number to the power of the first natural number, multiplied by that natural number to the power of the second natural number",theorem pow_pow2 (a m n : ℕ) : (a ^ m) ^ n = a ^ (m * n) := by,PowerClean.lean
pow_pow2,"Induct on n, with d = 0 as the base case and the inductive hypothesis (a ^ m) ^ t = a ^ (m * t). There are now two proof goals, prove base case: (a ^ m) ^ 0 = a ^ (m * 0) and inductive step: (a ^ m) ^ t = a ^ (m * t) implies (a ^ m) ^ succ t = a ^ (m * succ t).",induction n with t Ht,PowerClean.lean
pow_pow2,"We first rewrite m * 0 to 0, then rewrite (a ^ m) ^ 0 and a ^ 0 to 1, which simplifies the goal to 1 = 1.","rw [mul_zero, pow_zero, pow_zero]",PowerClean.lean
pow_pow2,"The goal is now to prove that 1 = 1, which is true by reflexivity",rfl,PowerClean.lean
pow_pow2,"Rewrite the left-hand side of the goal using the theorem that states (x^n)^(succ t) = (x^n)^t * (x^n). Then, use the induction hypothesis to replace (a^m)^t with a^(m⋆t). Next, rewrite the right-hand side of the goal using the theorem that states m*(succ t) = m\*t + m. Finally, rewrite the right-hand side again using the theorem that states x^(a+b) = x^a * x^b. This simplifies the goal to proving that a^(m\*t) * a^m is equal to a^(m*t) * a^m.","rw [pow_succ, Ht, mul_succ, pow_add]",PowerClean.lean
pow_pow2,"The goal is now to prove that a^(m\*t) * a^m = a^(m*t) * a^m, which is true by reflexivity",rfl,PowerClean.lean
add_sq,Prove that (a + b)^2 = a^2 + b^2 + 2 * a * b,theorem add_sq (a b : ℕ) : (a + b) ^ 2 = a ^ 2 + b ^ 2 + 2 * a * b := by,PowerClean.lean
add_sq,Rewrite (a + b)^2 as (a + b) * (a + b) using the theorem that x^2 = x * x,rw [pow_two],PowerClean.lean
add_sq,Rewrite a^2 as a * a using the theorem that x^2 = x * x,rw [pow_two],PowerClean.lean
add_sq,Rewrite b^2 as b * b using the theorem that x^2 = x * x,rw [pow_two],PowerClean.lean
add_sq,"Rearrange the terms on the right hand side of the equation, swapping the order of b * b and 2 * a * b using the commutative property of addition",rw [add_right_comm],PowerClean.lean
add_sq,Use the distributive property of multiplication over addition to expand (a + b) * (a + b) to a * (a + b) + b * (a + b),rw [mul_add],PowerClean.lean
add_sq,Use the distributive property to expand a * (a + b) to a * a + a * b,rw [add_mul],PowerClean.lean
add_sq,Use the distributive property to expand b * (a + b) to b * a + b * b,rw [add_mul],PowerClean.lean
add_sq,Rewrite 2 * a * b as a * b + a * b using the theorem that 2 * x = x + x,rw [two_mul],PowerClean.lean
add_sq,Use the distributive property to expand (a * b + a * b) to a * b + a * b,rw [add_mul],PowerClean.lean
add_sq,Rewrite b * a as a * b using the commutative property of multiplication,rw [mul_comm b a],PowerClean.lean
add_sq,Use the associative property of addition to rearrange (a * a + a * b) + (a * b + b * b) to a * a + (a * b + (a * b + b * b)),rw [← add_assoc],PowerClean.lean
add_sq,Use the associative property of addition again to rearrange a * a + (a * b + (a * b + b * b)) to a * a + a * b + (a * b + b * b),rw [← add_assoc],PowerClean.lean
add_sq,"The goal is now to prove that a * a + a * b + a * b + b * b = a * a + a * b + a * b + b * b, which is true by reflexivity",rfl,PowerClean.lean
add_sq2,Prove that (a + b)^2 = a^2 + b^2 + 2 * a * b,theorem add_sq2 (a b : ℕ) : (a + b) ^ 2 = a ^ 2 + b ^ 2 + 2 * a * b := by,PowerClean.lean
add_sq2,"Rewrite the expression for the square of (a + b), a^2, and b^2 to be (a + b) * (a + b), a * a, and b * b respectively.","rw [pow_two, pow_two, pow_two]",PowerClean.lean
add_sq2,"Rearrange the terms on the right hand side of the equation, swapping the order of b * b and 2 * a * b. This is based on the commutative property of addition, which states that the order of the terms does not change the result of the addition.",rw [add_right_comm],PowerClean.lean
add_sq2,rewrite the left-hand side of the equation using the distributive property of multiplication over addition. This expands (a + b) * (a + b) to a * a + b * a + a * b + b * b.,"rw [mul_add, add_mul, add_mul]",PowerClean.lean
add_sq2,"Rewrite the term 2 * a * b in the goal as (a * b + a * b) using the theorem that 2 times a number is the same as the number added to itself. Also, rewrite the term a * b + b * b as (a * b + a * b) + b * b using the theorem that the product of a sum is the sum of the products.","rw [two_mul, add_mul]",PowerClean.lean
add_sq2,"We rewrite the expression a * b as b * a in the goal. This is based on the commutative property of multiplication, which states that the order of the factors does not change the product. This results in the new goal: a * a + a * b + (a * b + b * b) = a * a + (a * b + a * b) + b * b.",rw [mul_comm b a],PowerClean.lean
add_sq2,We use the theorem that states the associativity of addition twice to rearrange the left-hand side of the equation. This changes the goal to proving that a * a + a * b + a * b + b * b equals a * a + a * b + a * b + b * b.,"rw [← add_assoc, ← add_assoc]",PowerClean.lean
add_sq2,"The goal is now to prove that a * a + a * b + a * b + b * b = a * a + a * b + a * b + b * b, which is true by reflexivity",rfl,PowerClean.lean
rfl_intro,"Prove for natural numbers x, q, that 37 * x + q = 37 * x + q",theorem rfl_intro (x q : ℕ) : 37 * x + q = 37 * x + q := by,TutorialClean.lean
rfl_intro,"Prove LHS and RHS are equal, 37 * x + q = 37 * x + q, completing the proof",rfl,TutorialClean.lean
add_zero_2,"Prove for natural numbers a, b, and c, that a + (b + 0) + (c + 0) is equal to a + b + c",theorem add_zero_2 (a b c : ℕ) : a + (b + 0) + (c + 0) = a + b + c := by,TutorialClean.lean
succ_eq_add_one,"For natural number n, prove that succ n is equivalent to n + 1",theorem succ_eq_add_one n : succ n = n + 1 := by,TutorialClean.lean
succ_eq_add_one,Rewrite RHS n + 1 as n + succ 0,rw [one_eq_succ_zero],TutorialClean.lean
succ_eq_add_one,Rewrite RHS from n + succ 0 to succ (n + 0),rw [add_succ],TutorialClean.lean
succ_eq_add_one,Simplify RHS succ (n + 0) to succ n,rw [add_zero],TutorialClean.lean
succ_eq_add_one,"Prove LHS and RHS are equal, succ n = succ n, completing the proof",rfl,TutorialClean.lean
twoaddtwo,Prove 2 + 2 = 4,theorem twoaddtwo : (2 : ℕ) + 2 = 4 := by,TutorialClean.lean
twoaddtwo,"Replace the second 2 in the LHS with succ 1, changing 2 + 2 to 2 + succ 1",nth_rewrite 2 [two_eq_succ_one],TutorialClean.lean
twoaddtwo,Rewrite LHS from 2 + succ 1 to succ (2 + 1),rw [add_succ],TutorialClean.lean
twoaddtwo,"Rewrite 1 as succ 0, so LHS changes from succ (2 + 1) to succ (2 + succ 0)",rw [one_eq_succ_zero],TutorialClean.lean
twoaddtwo,Rewrite the LHS from succ (2 + succ 0) to succ (succ (2 + 0)),rw [add_succ],TutorialClean.lean
twoaddtwo,"Simplify 2 + 0 to 2, changing LHS from succ (succ (2 + 0)) to succ (succ (2))",rw [add_zero],TutorialClean.lean
twoaddtwo,"Rewrite 4 as succ 3, changing RHS from 4 to succ 3",rw [four_eq_succ_three],TutorialClean.lean
twoaddtwo,"Rewrite 3 to succ 2, changing RHS from succ 3 to succ (succ (2))",rw [three_eq_succ_two],TutorialClean.lean
twoaddtwo,"Prove LHS and RHS are equal, succ (succ 2) = succ (succ 2), completing the proof",rfl,TutorialClean.lean
