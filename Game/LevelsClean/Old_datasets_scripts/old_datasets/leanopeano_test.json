[
  {
    "theorem": "add_assoc_2",
    "NL": "Prove that the addition of natural numbers is associative, i.e., a + b + c = a + (b + c).",
    "FL": "theorem add_assoc_2 (a b c : ℕ) : a + b + c = a + (b + c) := by",
    "filename": "AdditionClean.lean"
  },
  {
    "theorem": "add_assoc_2",
    "NL": "Induct on c, with d = 0 as the base case and the inductive hypothesis a + b + d = a + (b + d). There are now two proof goals, prove base case: a + b + 0 = a + (b + 0), and inductive step: a + b + succ (d) = a + (b + succ (d)).",
    "FL": "induction c with d hd",
    "filename": "AdditionClean.lean"
  },
  {
    "theorem": "add_assoc_2",
    "NL": "First we prove the base case. Simplify the LHS and RHS both to a + b",
    "FL": "· rw [add_zero, add_zero]",
    "filename": "AdditionClean.lean"
  },
  {
    "theorem": "add_assoc_2",
    "NL": "Prove LHS and RHS are equal, a + b = a + b, completing the base case.",
    "FL": "rfl",
    "filename": "AdditionClean.lean"
  },
  {
    "theorem": "add_assoc_2",
    "NL": "Now prove the inductive step. Rewrite the LHS: a + b + succ (d) to succ (a + b + d) and then to succ (a + (b + d)), using the inductive hypothesis. Change the RHS: a + (b + succ d) to a + succ (b + d) to succ (a + (b + d))",
    "FL": "· rw [add_succ, add_succ, hd, add_succ]",
    "filename": "AdditionClean.lean"
  },
  {
    "theorem": "add_assoc_2",
    "NL": "Prove LHS and RHS are equal, succ (a + (b + d)) = succ (a + (b + d)), completing the proof",
    "FL": "rfl",
    "filename": "AdditionClean.lean"
  },
  {
    "theorem": "add_left_eq_self",
    "NL": "Prove that x + y = y implies x = 0 for all natural numbers",
    "FL": "theorem add_left_eq_self (x y : ℕ) : x + y = y → x = 0 := by",
    "filename": "AdvAdditionClean.lean"
  },
  {
    "theorem": "add_left_eq_self",
    "NL": "Assume that x + y = y as our hypothesis h, and then prove that x = 0.",
    "FL": "intro h",
    "filename": "AdvAdditionClean.lean"
  },
  {
    "theorem": "add_left_eq_self",
    "NL": "Rewrite the second occurrence of the theorem 'zero_add y' in reverse in the hypothesis 'h', but the goal 'x = 0' remains unchanged.",
    "FL": "nth_rewrite 2 [← zero_add y] at h",
    "filename": "AdvAdditionClean.lean"
  },
  {
    "theorem": "add_left_eq_self",
    "NL": "If a + n = b + n, then a = b. So, in our case, if x + y = 0 + y, then x = 0.",
    "FL": "apply add_right_cancel at h",
    "filename": "AdvAdditionClean.lean"
  },
  {
    "theorem": "add_left_eq_self",
    "NL": "h proves the goal x = 0 so we can use it to finish the proof",
    "FL": "exact h",
    "filename": "AdvAdditionClean.lean"
  },
  {
    "theorem": "twenty",
    "NL": "Prove that 20 + 20 = 40",
    "FL": "theorem twenty: (20 : ℕ) + 20 = 40 := by",
    "filename": "Algorithm2Clean.lean"
  },
  {
    "theorem": "var_swap",
    "NL": "Prove (a + b) + (c + d) = ((a + c) + d) + b for natural numbers a, b, c, d",
    "FL": "theorem var_swap (a b c d : ℕ) : a + b + (c + d) = a + c + d + b := by",
    "filename": "AlgorithmClean.lean"
  },
  {
    "theorem": "var_swap",
    "NL": "Apply the associative property of addition to both sides of the equation to regroup the terms to a + (b + (c + d)) = a + (c + (d + b))",
    "FL": "repeat rw [add_assoc]",
    "filename": "AlgorithmClean.lean"
  },
  {
    "theorem": "var_swap",
    "NL": "Rewrite LHS, swapping b and c in the term b + c, to get a + (c + (b + d))",
    "FL": "rw [add_left_comm b c]",
    "filename": "AlgorithmClean.lean"
  },
  {
    "theorem": "var_swap",
    "NL": "Rewrite LHS from a + (c + (b + d)) to a + (c + (d + b))",
    "FL": "rw [add_comm b d]",
    "filename": "AlgorithmClean.lean"
  },
  {
    "theorem": "var_swap",
    "NL": "Prove LHS and RHS are equal, a + (c + (d + b)) = a + (c + (d + b)), completing the proof",
    "FL": "rfl",
    "filename": "AlgorithmClean.lean"
  },
  {
    "theorem": "exact_6",
    "NL": "For some x, which is a natural number, given x + 1 = 4, prove that x = 3",
    "FL": "theorem exact_6 (x : ℕ) (h : x + 1 = 4) : x = 3 := by",
    "filename": "ImplicationClean.lean"
  },
  {
    "theorem": "exact_6",
    "NL": "Change the proof goal to succ x = succ 3 using the injectivity of the successor function",
    "FL": "apply succ_inj",
    "filename": "ImplicationClean.lean"
  },
  {
    "theorem": "exact_6",
    "NL": "Rewrite the RHS, replacing 'succ x' with 'x + 1'.",
    "FL": "rw [succ_eq_add_one]",
    "filename": "ImplicationClean.lean"
  },
  {
    "theorem": "exact_6",
    "NL": "Simplify succ (3) to 4",
    "FL": "rw [← four_eq_succ_three]",
    "filename": "ImplicationClean.lean"
  },
  {
    "theorem": "exact_6",
    "NL": "We can exactly show that x + 1 = 4 holds true, assuming x = 3, completing the proof",
    "FL": "exact h",
    "filename": "ImplicationClean.lean"
  },
  {
    "theorem": "le_antisymm1",
    "NL": "Prove that if x is less than or equal to y and y is less than or equal to x, then x equals y.",
    "FL": "theorem le_antisymm1 (x y : ℕ) (hxy : x ≤ y) (hyx : y ≤ x) : x = y := by",
    "filename": "LessOrEqualClean.lean"
  },
  {
    "theorem": "le_antisymm1",
    "NL": "We consider the case where x is less than or equal to y so y = x + some natural number a.",
    "FL": "cases hxy with a ha",
    "filename": "LessOrEqualClean.lean"
  },
  {
    "theorem": "le_antisymm1",
    "NL": "We consider the case where y is less than or equal to x so x = y + some natural number b.",
    "FL": "cases hyx with b hb",
    "filename": "LessOrEqualClean.lean"
  },
  {
    "theorem": "le_antisymm1",
    "NL": "We substitute y in the goal with x + a, changing our goal to prove that x equals x + a.",
    "FL": "rw [ha]",
    "filename": "LessOrEqualClean.lean"
  },
  {
    "theorem": "le_antisymm1",
    "NL": "Using the equality y = x + a, we substitute y in the equation x = y + b with x + a. Then, we re-arrange the right side of the equation x = x + a + b to x = x + (a + b) using the property that addition is associative.",
    "FL": "rw [ha, add_assoc] at hb",
    "filename": "LessOrEqualClean.lean"
  },
  {
    "theorem": "le_antisymm1",
    "NL": "We flip the equation so that it reads 'x + (a + b) = x' instead of 'x = x + (a + b)'.",
    "FL": "symm at hb",
    "filename": "LessOrEqualClean.lean"
  },
  {
    "theorem": "le_antisymm1",
    "NL": "If x + (a + b) = x, then a + b = 0 by since for all natural numbers a and n, n + a = n implies a = 0.",
    "FL": "apply add_right_eq_self at hb",
    "filename": "LessOrEqualClean.lean"
  },
  {
    "theorem": "le_antisymm1",
    "NL": "If a + b = 0, then a = 0 and b = 0 by since for all natural numbers a and n, n + a = 0 implies a = 0.",
    "FL": "apply add_right_eq_zero at hb",
    "filename": "LessOrEqualClean.lean"
  },
  {
    "theorem": "le_antisymm1",
    "NL": "We substitute a in the equation x = x + a with zero, as given shown above, changing our goal to prove that x equals x.",
    "FL": "rw [hb, add_zero]",
    "filename": "LessOrEqualClean.lean"
  },
  {
    "theorem": "le_antisymm1",
    "NL": "The goal is now to prove that x equals x, which is true by reflexivity.",
    "FL": "rfl",
    "filename": "LessOrEqualClean.lean"
  },
  {
    "theorem": "one_mul",
    "NL": "Prove that 1 * m = m, for all natural numbers",
    "FL": "theorem one_mul (m : ℕ): 1 * m = m := by",
    "filename": "MultiplicationClean.lean"
  },
  {
    "theorem": "one_mul",
    "NL": "Apply the commutative property of multiplication to rewrite LHS from 1 * m to m * 1",
    "FL": "rw [mul_comm]",
    "filename": "MultiplicationClean.lean"
  },
  {
    "theorem": "one_mul",
    "NL": "Simplify m * 1 to m",
    "FL": "rw [mul_one]",
    "filename": "MultiplicationClean.lean"
  },
  {
    "theorem": "one_mul",
    "NL": "Prove LHS and RHS are equal, m = m, completing the proof",
    "FL": "rfl",
    "filename": "MultiplicationClean.lean"
  },
  {
    "theorem": "zero_pow_succ",
    "NL": "Prove that 0^(succ m) = 0",
    "FL": "theorem zero_pow_succ (m : ℕ) : (0 : ℕ) ^ (succ m) = 0 := by",
    "filename": "PowerClean.lean"
  },
  {
    "theorem": "zero_pow_succ",
    "NL": "Rewrite the left hand side using the identity that any natural number raised to the power of the successor of another natural number is equal to that number raised to the power of the other number, multiplied by the original number.",
    "FL": "rw [pow_succ]",
    "filename": "PowerClean.lean"
  },
  {
    "theorem": "zero_pow_succ",
    "NL": "Rewrite the left hand side using the identity that any natural number multiplied by 0 is 0",
    "FL": "rw [mul_zero]",
    "filename": "PowerClean.lean"
  },
  {
    "theorem": "zero_pow_succ",
    "NL": "The goal is now to prove that 0 = 0, which is true by reflexivity",
    "FL": "rfl",
    "filename": "PowerClean.lean"
  },
  {
    "theorem": "rw_intro",
    "NL": "Prove 2 * y = 2 * (x + 7) for natural numbers x, y, given that y = x + 7",
    "FL": "theorem rw_intro (x y : ℕ) (h : y = x + 7) : 2 * y = 2 * (x + 7) := by",
    "filename": "TutorialClean.lean"
  },
  {
    "theorem": "rw_intro",
    "NL": "Rewrite 2 * y in the LHS of the proof goal as 2 * (x + 7) using the fact that y = x + 7",
    "FL": "rw [h]",
    "filename": "TutorialClean.lean"
  },
  {
    "theorem": "rw_intro",
    "NL": "Prove LHS and RHS are equal, 2 * (x + 7) = 2 * (x + 7), completing the proof",
    "FL": "rfl",
    "filename": "TutorialClean.lean"
  }
]