World Name,Theorem Name,Natural Language,Predicted Formalization,True Tactic,True Goal State,Predicted Goal State,Is Correct
implication_world_val,exact_2,-- We simplify the hypothesis of 0 + x = 0 + y + 2 to x = 0 + x + 2.,rw [zero_add] at h,rw [zero_add] at h,"y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
","y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
",Yes
implication_world_val,exact_2,-- We simplify the hypothesis of x = 0 + y + 2 to x = y + 2.,rw [zero_add] at h,rw [zero_add] at h,"y x : ℕ
h : x = y + 2
⊢ x = y + 2
","y x : ℕ
h : x = y + 2
⊢ x = y + 2
",Yes
implication_world_val,exact_2,"-- So, x = y + 2, which is exactly what we wanted to prove.",exact h,exact h,,,Yes
implication_world_val,exact_2,-- 0 + x = 0 + y + 2 -> x = 0 + y + 2,rw [zero_add] at h,rw [zero_add] at h,"y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
","y x : ℕ
h : x = 0 + y + 2
⊢ x = y + 2
",Yes
implication_world_val,exact_2,-- x = 0 + y + 2 -> x = y + 2,rw [zero_add],rw [zero_add] at h,"y x : ℕ
h : x = y + 2
⊢ x = y + 2
",error,No
implication_world_val,exact_2,-- x = y + 2,exact h,exact h,,error,Yes
multiplication_world_val,zero_mul,-- Proof by induction on m with base case 0 * 0 = 0 and inductive step 0 * d + 1 = 0,induction m with d hd,induction m with d hd,"case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
","case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",Yes
multiplication_world_val,zero_mul,-- First prove base case. Simplify LHS 0 * 0 to 0,rw [mul_zero],rw [mul_zero],"case zero
⊢ 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
","case zero
⊢ 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",Yes
multiplication_world_val,zero_mul,-- The base case is not complete.,rfl,rfl,"case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
","case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",Yes
multiplication_world_val,zero_mul,"-- Now for the inductive step. Rewrite LHS 0 * succ (d) to 0 * d + 0, using the definition of multiplication",rw [mul_succ],rw [mul_succ],"case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * d + 0 = 0
","case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * d + 0 = 0
",Yes
multiplication_world_val,zero_mul,-- Simplify the LHS 0 * d + 0 to 0 + 0 using the definition of addition,rw [add_zero],rw [add_zero],"case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * d = 0
","case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * d = 0
",Yes
multiplication_world_val,zero_mul,-- This is exactly the inductive hypothesis so we can complete the proof.,rfl,exact hd,,error,No
multiplication_world_val,zero_mul,-- Proof by induction on m with base case 0 * 0 = 0 and inductive step 0 * d + 1 = 0,"induction m with d hd, { rw [mul_zero], }, { rw [mul_succ, hd, add_zero] }",induction m with d hd,"case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
","case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",Yes
multiplication_world_val,zero_mul,-- 0 * 0 = 0 -> 0 = 0,rfl,rw [mul_zero],"case zero
⊢ 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
","case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",No
multiplication_world_val,zero_mul,-- That proves the base case.,rfl,rfl,"case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
","case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",Yes
multiplication_world_val,zero_mul,-- 0 * succ d = 0 -> 0 * d + 0 = 0 -> 0 * d = 0,rw [mul_succ],"rw [mul_succ, add_zero]","case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * d = 0
","case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",No
multiplication_world_val,zero_mul,-- This is exactly the inductive hypothesis so we can complete the proof.,rfl,exact hd,,"case zero
⊢ 0 * 0 = 0
case succ
d : ℕ
hd : 0 * d = 0
⊢ 0 * succ d = 0
",No
AdvMultiplication_world_val,mul_left_ne_zero,-- Assume that b equals 0.,intro hd,intro hb,"a b : ℕ
h : a * b ≠ 0
hb : b = 0
⊢ False
","a b : ℕ
h : a * b ≠ 0
hd : b = 0
⊢ False
",Yes
AdvMultiplication_world_val,mul_left_ne_zero,-- Have to show that a * b = 0,apply h,apply h,"a b : ℕ
h : a * b ≠ 0
hb : b = 0
⊢ a * b = 0
","a b : ℕ
h : a * b ≠ 0
hd : b = 0
⊢ a * b = 0
",Yes
AdvMultiplication_world_val,mul_left_ne_zero,-- a * b = 0 -> a * 0 = 0 -> 0 = 0,"rw [hd, mul_zero]","rw [hb, mul_zero]","a b : ℕ
h : a * b ≠ 0
hb : b = 0
⊢ 0 = 0
","a b : ℕ
h : a * b ≠ 0
hd : b = 0
⊢ 0 = 0
",Yes
AdvMultiplication_world_val,mul_left_ne_zero,-- We use reflexivity to prove the goal of 0 = 0.,rfl,rfl,,,Yes
AdvMultiplication_world_val,mul_left_ne_zero,-- Assume that b equals 0.,intro hd,intro hd,"a b : ℕ
h : a * b ≠ 0
hd : b = 0
⊢ False
","a b : ℕ
h : a * b ≠ 0
hd : b = 0
⊢ False
",Yes
AdvMultiplication_world_val,mul_left_ne_zero,-- subtitute b with 0 which gives us a * 0 != 0,"rw [hd, mul_zero]",rw [hd] at h,"a b : ℕ
h : a * 0 ≠ 0
hd : b = 0
⊢ False
",error,No
AdvMultiplication_world_val,mul_left_ne_zero,-- a * 0 != 0 -> 0 != 0,"apply h, rw [hd, mul_zero]",rw [mul_zero] at h,"a b : ℕ
h : 0 ≠ 0
hd : b = 0
⊢ False
",error,No
AdvMultiplication_world_val,mul_left_ne_zero,-- We have 0 != 0 which is a contradiction.,rfl,tauto,,error,No
algorithm_world_val,add_left_comm,"-- By associativity of addition, can change a + (b + c) into (a + b) + c",rw [add_assoc],rw [← add_assoc],"a b c : ℕ
⊢ a + b + c = b + (a + c)
",error,No
algorithm_world_val,add_left_comm,"-- By the commutativity of addition, can change (a + b) + c into (b + a) + c",rw [add_comm a b],rw [add_comm a b],"a b c : ℕ
⊢ b + a + c = b + (a + c)
",error,Yes
algorithm_world_val,add_left_comm,"-- By the associativity of addition, can change (b + a) + c into b + (a + c)",rw [add_assoc],rw [add_assoc],"a b c : ℕ
⊢ b + (a + c) = b + (a + c)
",error,Yes
algorithm_world_val,add_left_comm,"-- So we just need to show b + (a + c) = b + (a + c), which is true by reflexivity.",rfl,rfl,,error,Yes
algorithm_world_val,add_left_comm,-- a + (b + c) = b + (a + c) -> (a + b) + c = b + (a + c),rw [←add_assoc],rw [← add_assoc],"a b c : ℕ
⊢ a + b + c = b + (a + c)
","a b c : ℕ
⊢ a + b + c = b + (a + c)
",Yes
algorithm_world_val,add_left_comm,-- (a + b) + c = b + (a + c) -> (b + a) + c = b + (a + c),rw [add_comm a b],rw [add_comm a b],"a b c : ℕ
⊢ b + a + c = b + (a + c)
","a b c : ℕ
⊢ b + a + c = b + (a + c)
",Yes
algorithm_world_val,add_left_comm,-- (b + a) + c = b + (a + c) -> b + (a + c) = b + (a + c),rfl,rw [add_assoc],"a b c : ℕ
⊢ b + (a + c) = b + (a + c)
",error,No
algorithm_world_val,add_left_comm,-- lhs = rhs,rfl,rfl,,error,Yes
less_or_equal_world_val,le_two,-- Either x = 0 or x = succ y for some natural number y.,cases x with y,cases x with y,"case zero
hx : 0 ≤ 2
⊢ 0 = 0 ∨ 0 = 1 ∨ 0 = 2
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero
hx : 0 ≤ 2
⊢ 0 = 0 ∨ 0 = 1 ∨ 0 = 2
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes
less_or_equal_world_val,le_two,"-- In the former case, we need to show 0 = 0 ∨ 0 = 1 ∨ 0 = 2, and we choose to show 0 = 0.","left, rfl",left,"case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes
less_or_equal_world_val,le_two,-- This is clear by reflexivity.,rfl,rfl,"case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes
less_or_equal_world_val,le_two,"-- In the latter case, either y = 0 or y = succ z for some natural number z.",cases y with z,cases y with z,"case succ.zero
hx : succ 0 ≤ 2
⊢ succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes
less_or_equal_world_val,le_two,"-- In the former case, we must show succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2, and we choose to prove succ 0 = 1 ∨ succ 0 = _dev_2",right,right,"case succ.zero.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes
less_or_equal_world_val,le_two,"-- To prove succ 0 = 1 ∨ succ 0 = 2, we choose to prove succ 0 = _dev_1",left,left,"case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes
less_or_equal_world_val,le_two,"-- Rewriting using a theorem, need to show show succ 0 = succ 0.",rfl,rw [one_eq_succ_zero],"case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = succ 0
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No
less_or_equal_world_val,le_two,-- This is clear by reflexivity.,rfl,rfl,"case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes
less_or_equal_world_val,le_two,"-- In the latter case, we substitute 2 = succ 1 and 1 = succ 0 into what we know and what we have to show.","rw [two_eq_succ_one, one_eq_succ_zero] at hx ⊢","rw [two_eq_succ_one, one_eq_succ_zero] at hx ⊢","case succ.succ
z : ℕ
hx : succ (succ z) ≤ succ (succ 0)
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes
less_or_equal_world_val,le_two,"-- We know that succ (succ z) ≤ succ (succ 0), so usinig a theorem we know succ z ≤ succ 0.",apply succ_le_succ at hx,apply succ_le_succ at hx,"case succ.succ
z : ℕ
hx : succ z ≤ succ 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes
less_or_equal_world_val,le_two,"-- We know that succ z ≤ succ 0, so using a theorem we know that z ≤ 0.",apply succ_le_succ at hx,apply succ_le_succ at hx,"case succ.succ
z : ℕ
hx : z ≤ 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes
less_or_equal_world_val,le_two,"-- Since z ≤ 0, using a theorem, z = 0.",apply le_zero at hx,apply le_zero at hx,"case succ.succ
z : ℕ
hx : z = 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes
less_or_equal_world_val,le_two,-- We subsitute z = 0 into what we want to show.,rw [hx],rw [hx],"case succ.succ
z : ℕ
hx : z = 0
⊢ succ (succ 0) = 0 ∨ succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes
less_or_equal_world_val,le_two,"-- So, we need to show that succ (succ 0) = 0 ∨ succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0), so we choose to show that succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0)",right,right,"case succ.succ.h
z : ℕ
hx : z = 0
⊢ succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes
less_or_equal_world_val,le_two,"-- We need to show that succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0), so we choose to show that succ (succ 0) = succ (succ 0)",rfl,right,"case succ.succ.h.h
z : ℕ
hx : z = 0
⊢ succ (succ 0) = succ (succ 0)
","case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No
less_or_equal_world_val,le_two,"-- But LHS = RHS, so this follows by reflexivity.",rfl,rfl,,"case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes
less_or_equal_world_val,le_two,-- x = 0 (case 1) or x = succ y (case 2) for some natural number y,cases x with y,cases x with y,"case zero
hx : 0 ≤ 2
⊢ 0 = 0 ∨ 0 = 1 ∨ 0 = 2
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case zero
hx : 0 ≤ 2
⊢ 0 = 0 ∨ 0 = 1 ∨ 0 = 2
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",Yes
less_or_equal_world_val,le_two,-- 0 = 0 ∨ 0 = 1 ∨ 0 = 2 -> 0 = 0,trivial,left,"case zero.h
hx : 0 ≤ 2
⊢ 0 = 0
case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
","case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",No
less_or_equal_world_val,le_two,-- lhs = rhs,rfl,rfl,"case succ
y : ℕ
hx : succ y ≤ 2
⊢ succ y = 0 ∨ succ y = 1 ∨ succ y = 2
",error,Yes
less_or_equal_world_val,le_two,-- y = 0 (case 1) or y = succ z (case 2) for some natural number z,cases y with z,cases y with z,"case succ.zero
hx : succ 0 ≤ 2
⊢ succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",error,Yes
less_or_equal_world_val,le_two,-- succ 0 = 0 ∨ succ 0 = 1 ∨ succ 0 = 2 -> succ 0 = 1 ∨ succ 0 = _dev_2,left,right,"case succ.zero.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1 ∨ succ 0 = 2
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",error,No
less_or_equal_world_val,le_two,-- succ 0 = 1 ∨ succ 0 = 2 -> succ 0 = _dev_1,left,left,"case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = 1
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",error,Yes
less_or_equal_world_val,le_two,-- succ 0 = 1 -> succ 0 = succ 0,rfl,rw [one_eq_succ_zero],"case succ.zero.h.h
hx : succ 0 ≤ 2
⊢ succ 0 = succ 0
case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",error,No
less_or_equal_world_val,le_two,-- lhs = rhs,rfl,rfl,"case succ.succ
z : ℕ
hx : succ (succ z) ≤ 2
⊢ succ (succ z) = 0 ∨ succ (succ z) = 1 ∨ succ (succ z) = 2
",error,Yes
less_or_equal_world_val,le_two,-- succ (succ z) ≤ 2 -> succ (succ z) ≤ succ 1 -> succ (succ z) ≤ succ (succ 0); ... = 0 ∨ ... = 1 ∨ ... = 2 -> ... = 0 ∨ ... = 1 ∨ ... = succ 1 -> ... = 0 ∨ ... = succ 0 ∨ ... = succ (succ 0),"rw [two_eq_succ_one, one_eq_succ_zero] at hx ⊢","rw [two_eq_succ_one, one_eq_succ_zero] at hx ⊢","case succ.succ
z : ℕ
hx : succ (succ z) ≤ succ (succ 0)
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
",error,Yes
less_or_equal_world_val,le_two,-- succ (succ z) ≤ succ (succ 0) -> succ z ≤ succ 0,apply succ_le_succ at hx,apply succ_le_succ at hx,"case succ.succ
z : ℕ
hx : succ z ≤ succ 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
",error,Yes
less_or_equal_world_val,le_two,-- succ z ≤ succ 0 -> z ≤ 0,apply succ_le_succ at hx,apply succ_le_succ at hx,"case succ.succ
z : ℕ
hx : z ≤ 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
",error,Yes
less_or_equal_world_val,le_two,-- z ≤ 0 -> z = 0,apply le_zero at hx,apply le_zero at hx,"case succ.succ
z : ℕ
hx : z = 0
⊢ succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0)
",error,Yes
less_or_equal_world_val,le_two,-- succ (succ z) = 0 ∨ succ (succ z) = succ 0 ∨ succ (succ z) = succ (succ 0) -> succ (succ 0) = 0 ∨ succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0),rw [hx],rw [hx],"case succ.succ
z : ℕ
hx : z = 0
⊢ succ (succ 0) = 0 ∨ succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0)
",error,Yes
less_or_equal_world_val,le_two,-- succ (succ 0) = 0 ∨ succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0) -> succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0),right,right,"case succ.succ.h
z : ℕ
hx : z = 0
⊢ succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0)
",error,Yes
less_or_equal_world_val,le_two,-- succ (succ 0) = succ 0 ∨ succ (succ 0) = succ (succ 0) -> succ (succ 0) = succ (succ 0),rfl,right,"case succ.succ.h.h
z : ℕ
hx : z = 0
⊢ succ (succ 0) = succ (succ 0)
",error,No
less_or_equal_world_val,le_two,-- lhs = rhs,rfl,rfl,,error,Yes
power_world_val,zero_pow_succ,"-- We know that 0^(succ m) = 0^m * 0, so our goal becomes 0^m * 0 = 0",rw [mul_zero],rw [pow_succ],"m : ℕ
⊢ 0 ^ m * 0 = 0
",error,No
power_world_val,zero_pow_succ,-- 0=0,rfl,rw [mul_zero],"m : ℕ
⊢ 0 = 0
",error,No
power_world_val,zero_pow_succ,"-- lhs = rhs, so we are done.",rfl,rfl,,error,Yes
power_world_val,zero_pow_succ,"-- We can use induction on m. For the base case, we want to show that 0^succ(0) = 0.",induction m with d hd,induction m with h hd,"case zero
⊢ 0 ^ succ 0 = 0
case succ
h : ℕ
hd : 0 ^ succ h = 0
⊢ 0 ^ succ (succ h) = 0
","case zero
⊢ 0 ^ succ 0 = 0
case succ
d : ℕ
hd : 0 ^ succ d = 0
⊢ 0 ^ succ (succ d) = 0
",Yes
power_world_val,zero_pow_succ,"-- Using the fact that 1 is the successor of zero, we write 0^1 = 0.",rw [pow_one],rw[← one_eq_succ_zero],"case zero
⊢ 0 ^ 1 = 0
case succ
h : ℕ
hd : 0 ^ succ h = 0
⊢ 0 ^ succ (succ h) = 0
",error,No
power_world_val,zero_pow_succ,"-- We know that anything to the power of one is equal to itself, so our goal becomes: 0 = 0",rfl,rw[pow_one],"  ?a ^ 1
case zero
⊢ 0 ^ 1 = 0
",error,No
power_world_val,zero_pow_succ,"-- We can conclude the proof by reflexivity, as the LHS and RHS of our goal are identical.",rfl,rfl,"  ?a ^ 1
case zero
⊢ 0 ^ 1 = 0
",error,Yes
power_world_val,zero_pow_succ,"-- Next, we consider the inductive case, where we want to show that 0^succ(succ m) = 0. By the successor definition of the power function, we can write our goal as: 0^succ(m) * 0 = 0.",rw [pow_succ],rw[pow_succ],"  ?a ^ 1
case zero
⊢ 0 ^ 1 = 0
",error,No
power_world_val,zero_pow_succ,"-- We see that we can apply our inductive hypothesis, that 0^succ(m) = 0, and our goal becomes: 0*0 = 0",rw [mul_zero],rw[hd],"  ?a ^ 1
case zero
⊢ 0 ^ 1 = 0
",error,No
power_world_val,zero_pow_succ,"-- Anything multiplied by zero is zero, so we simplify to: 0*0",rw [mul_zero],rw[mul_zero],"  ?a ^ 1
case zero
⊢ 0 ^ 1 = 0
",error,No
power_world_val,zero_pow_succ,"-- The lhs and rhs are identical, so we are done by reflexivity.",rfl,rfl,"  ?a ^ 1
case zero
⊢ 0 ^ 1 = 0
",error,Yes
tutorial_world_val,succ_eq_add_one,-- Rewrite on both RHS and LHS making n -> n + 0,rw [add_zero],rw [← add_zero n],"n : ℕ
⊢ succ (n + 0) = n + 0 + 1
",error,No
tutorial_world_val,succ_eq_add_one,-- Rewrite on RHS making 1 -> succ 0,rw [one_eq_succ_zero],rw [one_eq_succ_zero],"n : ℕ
⊢ succ (n + 0) = n + 0 + succ 0
",error,Yes
tutorial_world_val,succ_eq_add_one,-- Rewrite on RHS making n + 0 + succ(0) -> succ(n+0+0),rw [add_succ],rw [add_succ],"n : ℕ
⊢ succ (n + 0) = succ (n + 0 + 0)
",error,Yes
tutorial_world_val,succ_eq_add_one,-- Rewrite on RHS making n + 0 -> n,rw [add_zero],rw [add_zero (n+0)],"n : ℕ
⊢ succ (n + 0) = succ (n + 0)
",error,No
tutorial_world_val,succ_eq_add_one,"-- succ(n+0) = succ(n+0), QED",rfl,rfl,,error,Yes
tutorial_world_val,succ_eq_add_one,-- Rewrite RHS 1 -> succ(0),rw [one_eq_succ_zero],rw [one_eq_succ_zero],"n : ℕ
⊢ succ n = n + succ 0
","n : ℕ
⊢ succ n = n + succ 0
",Yes
tutorial_world_val,succ_eq_add_one,-- Rewrite both RHS and LHS n -> n + 0,rw [add_zero],rw [← add_zero n],"n : ℕ
⊢ succ (n + 0) = n + 0 + succ 0
",error,No
tutorial_world_val,succ_eq_add_one,-- Rewrite RHS n + 0 + succ(0) -> succ(n + 0 + 0),rw [add_succ],rw [add_succ],"n : ℕ
⊢ succ (n + 0) = succ (n + 0 + 0)
",error,Yes
tutorial_world_val,succ_eq_add_one,-- Rewrite LHS and RHS n + 0 -> n,rw [add_zero],rw [add_zero],"n : ℕ
⊢ succ n = succ (n + 0)
",error,Yes
tutorial_world_val,succ_eq_add_one,-- Rewrite RHS n + 0 -> n,rw [add_zero],rw [add_zero],"n : ℕ
⊢ succ n = succ n
",error,Yes
tutorial_world_val,succ_eq_add_one,"-- succ(n) = succ(n), QED",rfl,rfl,,error,Yes
AdvAddition_world_val,add_right_eq_zero,"-- We have two cases: b = 0, or b = succ d for some natural number d.",cases b with d,cases b with d,"case zero
a : ℕ
⊢ a + 0 = 0 → a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case zero
a : ℕ
⊢ a + 0 = 0 → a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes
AdvAddition_world_val,add_right_eq_zero,"-- In the former case, we must show that a + 0 = 0 → a = 0, so we start by assuming that a + 0 = 0.",intro h,intro h,"case zero
a : ℕ
h : a + 0 = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case zero
a : ℕ
h : a + 0 = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes
AdvAddition_world_val,add_right_eq_zero,-- We apply the theorem that n + 0 = n change a + 0 = 0 into a = 0.,rw [add_zero] at h,rw [add_zero] at h,"case zero
a : ℕ
h : a = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case zero
a : ℕ
h : a = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes
AdvAddition_world_val,add_right_eq_zero,"-- So, a = 0, which concludes this case of the theorem.",exact h,exact h,"case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes
AdvAddition_world_val,add_right_eq_zero,"-- In the latter case, we must show that a + succ d = 0 → a = 0, so we start by assuming that a + succ d = 0.",intro h,intro h,"case succ
a d : ℕ
h : a + succ d = 0
⊢ a = 0
","case succ
a d : ℕ
h : a + succ d = 0
⊢ a = 0
",Yes
AdvAddition_world_val,add_right_eq_zero,"-- Using the theorem that a + succ d = succ (a + d), we get that succ (a + d) = 0.",rw [add_succ] at h,rw [add_succ] at h,"case succ
a d : ℕ
h : succ (a + d) = 0
⊢ a = 0
","case succ
a d : ℕ
h : succ (a + d) = 0
⊢ a = 0
",Yes
AdvAddition_world_val,add_right_eq_zero,"-- By the symmetry of equality, we have that 0 = succ (a + d).",symm at h,symm at h,"case succ
a d : ℕ
h : 0 = succ (a + d)
⊢ a = 0
","case succ
a d : ℕ
h : 0 = succ (a + d)
⊢ a = 0
",Yes
AdvAddition_world_val,add_right_eq_zero,"-- But since 0 is not the successor of anything, we have a contradiction/falsehood.",cases h,apply zero_ne_succ at h,"case succ
a d : ℕ
h : False
⊢ a = 0
",,No
AdvAddition_world_val,add_right_eq_zero,"-- Since a contradiction/falsehood implies anything, we are done.",cases h,cases h,,error,Yes
AdvAddition_world_val,add_right_eq_zero,-- either b = 0 or b = succ d for some natural number d,cases b with d,cases b with d,"case zero
a : ℕ
⊢ a + 0 = 0 → a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case zero
a : ℕ
⊢ a + 0 = 0 → a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes
AdvAddition_world_val,add_right_eq_zero,-- (case 1) assume a + 0 = 0,intro h,intro h,"case zero
a : ℕ
h : a + 0 = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case zero
a : ℕ
h : a + 0 = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes
AdvAddition_world_val,add_right_eq_zero,-- a + 0 = 0 -> a = 0,rw [add_zero] at h,rw [add_zero] at h,"case zero
a : ℕ
h : a = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case zero
a : ℕ
h : a = 0
⊢ a = 0
case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes
AdvAddition_world_val,add_right_eq_zero,"-- a = 0, as desired",exact h,exact h,"case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
","case succ
a d : ℕ
⊢ a + succ d = 0 → a = 0
",Yes
AdvAddition_world_val,add_right_eq_zero,-- (case 2) assume a + succ d = 0,intro h,intro h,"case succ
a d : ℕ
h : a + succ d = 0
⊢ a = 0
","case succ
a d : ℕ
h : a + succ d = 0
⊢ a = 0
",Yes
AdvAddition_world_val,add_right_eq_zero,-- a + succ d = 0 -> succ (a + d) = 0,rw [add_succ] at h,rw [add_succ] at h,"case succ
a d : ℕ
h : succ (a + d) = 0
⊢ a = 0
","case succ
a d : ℕ
h : succ (a + d) = 0
⊢ a = 0
",Yes
AdvAddition_world_val,add_right_eq_zero,-- succ (a + d) = 0 -> 0 = succ (a + d),symm at h,symm at h,"case succ
a d : ℕ
h : 0 = succ (a + d)
⊢ a = 0
","case succ
a d : ℕ
h : 0 = succ (a + d)
⊢ a = 0
",Yes
AdvAddition_world_val,add_right_eq_zero,-- 0 = succ (a + d) -> False,apply zero_ne_succ at h,apply zero_ne_succ at h,"case succ
a d : ℕ
h : False
⊢ a = 0
","case succ
a d : ℕ
h : False
⊢ a = 0
",Yes
AdvAddition_world_val,add_right_eq_zero,-- False -> anything,cases h,cases h,,,Yes
addition_world_val,zero_add,-- Induct on n,induction n with d hd,induction n with d hd,"case zero
⊢ 0 + 0 = 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
","case zero
⊢ 0 + 0 = 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
",Yes
addition_world_val,zero_add,-- substitute 0 -> 0 + 0 into the RHS giving us 0 + 0 = 0 + 0,rw [add_zero],nth_rewrite 3 [← add_zero 0],"case zero
⊢ 0 + 0 = 0 + 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
","case zero
⊢ 0 = 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
",No
addition_world_val,zero_add,"-- 0 + 0 = 0 + 0, completing base case",rfl,rfl,"case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
","case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
",Yes
addition_world_val,zero_add,-- 0 + succ d -> succ (0 + d) on LHS giving us succ (0 + d) = succ d,rw [add_succ],rw [add_succ],"case succ
d : ℕ
hd : 0 + d = d
⊢ succ (0 + d) = succ d
","case succ
d : ℕ
hd : 0 + d = d
⊢ succ (0 + d) = succ d
",Yes
addition_world_val,zero_add,-- 0 + d -> d on LHS -> succ d = succ d,rw [hd],rw [hd],"case succ
d : ℕ
hd : 0 + d = d
⊢ succ d = succ d
","case succ
d : ℕ
hd : 0 + d = d
⊢ succ d = succ d
",Yes
addition_world_val,zero_add,"-- succ d = succ d, QED",rfl,rfl,,,Yes
addition_world_val,zero_add,-- Begin by initiating induction on n,induction n with d hd,induction n with d hd,"case zero
⊢ 0 + 0 = 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
","case zero
⊢ 0 + 0 = 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
",Yes
addition_world_val,zero_add,-- Using the properties of addition by 0 we can rewrite 0 + 0 to 0 on the LHS,rw [add_zero],rw [add_zero],"case zero
⊢ 0 = 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
","case zero
⊢ 0 = 0
case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
",Yes
addition_world_val,zero_add,"-- Since both sides are equal, we are done with the base case",rfl,rfl,"case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
","case succ
d : ℕ
hd : 0 + d = d
⊢ 0 + succ d = succ d
",Yes
addition_world_val,zero_add,-- Now using properties of successors we can rewrite 0 + succ d to succ (0 + d) on the LHS getting succ (0 + d) = succ d,rw [add_succ],rw [add_succ],"case succ
d : ℕ
hd : 0 + d = d
⊢ succ (0 + d) = succ d
","case succ
d : ℕ
hd : 0 + d = d
⊢ succ (0 + d) = succ d
",Yes
addition_world_val,zero_add,-- Using the induction hypothesis we can rewrite succ (0 + d) to succ d,rw [hd],rw [hd],"case succ
d : ℕ
hd : 0 + d = d
⊢ succ d = succ d
","case succ
d : ℕ
hd : 0 + d = d
⊢ succ d = succ d
",Yes
addition_world_val,zero_add,"-- Since both sides are equal, we are done with the proof",rfl,rfl,,,Yes
